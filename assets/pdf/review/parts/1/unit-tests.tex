\chapterimage{chapter_head_2.pdf}

\chapter{Unit Tests}

\begin{center}
    Test code is just as important as production code.
\end{center}

We have barely scratched the surface of tests. Tests are as important to the health of a project as the production code
is. Perhaps they are even more important, because tests preserve and enhance the flexibility, \textbf{maintainability},
and reusability of the production code. So keep your tests constantly clean. Work to make them expressive and succinct.
Invent testing APIs that act as domain-specific language that helps you write the tests. If you let the tests rot, then
your code will rot too. Keep your tests clean.

\section{The Three Laws of TDD(Test Driven Development)}\index{Unit Tests!The Three Laws of TDD}

\begin{tcolorbox}[breakable, colback=blue!10!white, colframe=blue!85!black, title=The Three Laws of TDD]
\begin{enumerate}
    \item You may not write production code until you have written a failing unit test.
    \item You may not write more of a unit test than is sufficient to fail, and not compiling is failing.
    \item You may not write more production code than is sufficient to pass the currently failing test.
\end{enumerate}
\end{tcolorbox}

\section{Clean Tests}\index{Unit Tests!Clean Tests}

What makes a clean test? Three things:

\begin{enumerate}
    \item Readability
    \item Readability
    \item Readability
\end{enumerate}

What makes tests readable? The same thing that makes all code readable: clarity, simplicity, and density of expression.
To be more specific:

\begin{itemize}
    \item No code duplication
    \item Less code details that interfere with the expressions of test
    \item Clear separation of setup, run, and test results(with the help of domain-specific testing language to simplify
    and shorten tests)
\end{itemize}

\section{F.I.R.S.T.}\index{Unit Tests!F.I.R.S.T.}

Clean tests follow five rules.

\textbf{Fast} Tests should be fast. They should run quickly. When tests run slow, you won't want to run them frequently.
If you don't run them frequently, you won't find problems early enough to fix them easily. You won't feel as free to
clean up the code. Eventually the code will begin to rot.

\textbf{Independent} Tests should not depend on each other. One test should not set up the conditions for the next test.
You should be able to run each test independently and run the tests in any order you like. When tests depend on each
other, then the first one to fail causes a cascade of downstream failures, making diagnosis difficult and hiding
downstream defects.

\textbf{Repeatable} Tests should be repeatable in any environment. You should be able to run the tests in the production
environment, in the QA environment, and on your laptop while riding home on the train without a network. If your tests
aren't repeatable in any environment, then you'll always have an excuse for why they fail. You'll also find yourself
unable to run the tests when the environment isn't available.

\textbf{Self-Validating} The tests should have a boolean output. Either they pass or fail. You should not have to read
through a log file to tell whether the tests pass. You should not have to manually compare two different text files to
see whether the tests pass. If the tests aren't self-validating, then failure can become subjective and running the
tests can require a long manual evaluation.

\textbf{Timely} The tests need to be written in a timely fashion. Unit tests should be written just before the
production code that makes them pass. If you write tests after the production code, then you may find the production
code to be hard to test. You may decide that some production code is too hard to test. You may not design the production
code to be testable.
