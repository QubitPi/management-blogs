\chapterimage{chapter_head_2.pdf}

\chapter{Meaningful Names}

The hardest thing about choosing good names is that it requires \textbf{good descriptive skills} and \textbf{a shared cultural background}. This is a teaching issue rather than a technical, business, or management issue. As a result many people in this field don't learn to do it very well.

Follow the rules above and do not afraid to make changes on other's code accordinly. It pays in both short and long terms

\section{Use Intention-Revealing Names}\index{Naming!Use Intention-Revealing Names}

Everyone who reads your code (including you) will be happier if you take care with your naming.

\subsection{Variable Declaration should not \textit{require} a comment}

\href{https://checkstyle.sourceforge.io/config_javadoc.html?--#JavadocVariable}{While it is a good Java practice to comment variables of a class}, the name of a variable, function, or class, should have already answered all the big questions. It should tell you why it exists, what it does, and how it is used.
If a name requires a comment, then the name does not reveal its intent.

\begin{marker}
\textbf{If a name requires a comment, then the name does not reveal its intent.}
\end{marker}

For example:

\begin{tcolorbox}[breakable, colback=red!10!white, colframe=red!85!black, sidebyside, righthand width = 3cm, tikz lower]

\begin{lstlisting}[language = java]
int d; // elapsed time in days
\end{lstlisting}

\tcblower

\path[fill = yellow, draw = yellow!75!red] (0, 0) circle (1cm);
\fill[red] (45:5mm) circle (1mm);
\fill[red] (135:5mm) circle (1mm);
\draw[line width=1mm,red] (230:6mm) arc (145:35:5mm);

\end{tcolorbox}

The name \ubuntubox{\lstinline{d}} reveals nothing. It does not evoke a sense of elapsed time, nor of days. We should choose a name that specifies what is being measured and the unit of that measurement:

\begin{tcolorbox}[breakable, colback=green!10!white, colframe=green!85!black, sidebyside, righthand width = 3cm, tikz lower]

\begin{lstlisting}[language = java]
int elapsedTimeInDays;
int daysSinceCreation;
int daysSinceModification;
int fileAgeInDays;
\end{lstlisting}

\tcblower

\path[fill = yellow, draw = yellow!75!red] (0, 0) circle (1cm);
\fill[red] (45:5mm) circle (1mm);
\fill[red] (135:5mm) circle (1mm);
\draw[line width=1mm,red] (215:5mm) arc (215:325:5mm);

\end{tcolorbox}

\subsection{Promote simplicity and \textbf{IMPLICITY}}

\begin{tcolorbox}[breakable, colback=red!10!white, colframe=red!85!black, sidebyside, righthand width = 3cm, tikz lower]

\begin{lstlisting}[language = java]
public List<int[]> getThem() {
    List<int[]> list1 = new ArrayList<int[]>();
    
    for (int[] x : theList) {
        if (x[0] == 4) {
            list1.add(x);
        }
    }

    return list1;
}
\end{lstlisting}

\tcblower

\path[fill = yellow, draw = yellow!75!red] (0, 0) circle (1cm);
\fill[red] (45:5mm) circle (1mm);
\fill[red] (135:5mm) circle (1mm);
\draw[line width=1mm,red] (230:6mm) arc (145:35:5mm);

\end{tcolorbox}

Why is it hard to tell what this code is doing? Although code syntax is not complicated, the problem is not the simplicity of the code but the \textit{implicity} of the code.

\begin{definition}[Implicity of the Code]
The degree to which the context is not explicit in the code itself
\end{definition}

The code implicitly requires that we know the answers to questions such as:

\begin{itemize}
    \item What kinds of things are in \inlinecode[blue]{theList}?
    \item What is the significance of the zeroth subscript of an item in \inlinecode[blue]{theList}?
    \item What is the significance of the value 4?
    \item How would I use the list being returned?
\end{itemize}

The answers to these questions are not present in the code sample, but they could have been.

\begin{marker}
\textbf{The code review should point out the problem and the re-review should make sure that simplicity of the code has not changed.}
\end{marker}

\section{Avoid Disinformation}\index{Naming!Avoid Disinformation}

\subsubsection{Sub-type Naming}

Java usually declares variables by type and always assigns variables with concrete implementation. A variable should not be named by a sub-type name if the type could be different type nature. For example, when a variable's type is \inlinecode[blue]{Collection} and is assigned a \inlinecode[blue]{ArrayList}, it should not be named as something like \inlinecode[red]{peopleList}; instead \inlinecode[green]{peopleGroup} or simply \inlinecode[green]{persons} would be better.

\begin{marker}
\textbf{A variable should not be named by a sub-type name if the type could be different type nature.}
\end{marker}

\subsubsection{Avoid Names That Vary in Small Ways}

Long and smilarly-named variables are very hard for people to read and distinguish. For example How long does it take to spot the subtle difference between a \inlinecode[red]{XYZControllerForEfficientHandlingOfStrings} in one module and, somewhere a little more distant, \inlinecode[red]{XYZControllerForEfficientStorageOfStrings}?

In addition, developer using IDE uses auto-complete feature. They will often blindly pick up the wrong variable simply because the two looks so similar.

\section{Make Meaningful Distinctions}\index{Naming!Make Meaningful Distinctions}

By all possible means, people could name two things with non-meaningful distinctions. For example, class \inlinecode[red]{Product} v.s. class \inlinecode[red]{ProductInfo}. What are the difference between the two? Product can have product info, too. Same issues goes for methods:

\begin{tcolorbox}[breakable, colback=red!10!white, colframe=red!85!black, sidebyside, righthand width = 3cm, tikz lower]

\begin{lstlisting}[language = java]
getActiveAccount();
getActiveAccounts();
getActiveAccountInfo();
\end{lstlisting}

\tcblower

\path[fill = yellow, draw = yellow!75!red] (0, 0) circle (1cm);
\fill[red] (45:5mm) circle (1mm);
\fill[red] (135:5mm) circle (1mm);
\draw[line width=1mm,red] (230:6mm) arc (145:35:5mm);

\end{tcolorbox}

How are the programmers in this project supposed to know which of these functions to call?

\subsection{Use Speakable/Pronouncable Names}\index{Naming!Use Speakable/Pronouncable Names}

\begin{remark}
Humans are good at words. A significant part of our brains is dedicated to the concept of words. Words are pronounceable
\end{remark}

If you can't pronounce it, you can't discuss it without sounding like an idiot. “Well, over here on the bee cee arr three cee enn tee we have a pee ess zee kyew int, see?” This matters because \textit{programming is a social activity}.

\begin{marker}
Use Speakable/Pronounceable Names
\end{marker}

\section{Use Searchable Names}\index{Naming!Use Searchable Names}

Single-letter names and numeric constants have a particular problem in that they are not easy to locate across a body of text.

My personal preference is that single-letter names can ONLY be used as local variables inside short methods.\textit{The length of a name should correspond to the size of its scope} If a variable or constant might be seen or used in multiple places in a body of code, it is imperative to give it a search-friendly name.

\begin{marker}
Use Searchable Names
\end{marker}

\section{Don't Add Gratuitous Context}\index{Naming!Don't Add Gratuitous Context}

In an imaginary application called “Gas Station Deluxe,” it is a bad idea to prefix every class with \inlinecode[red]{GSD}. Frankly, you are working against your tools. You type "G" and press the completion key and are rewarded with a mile-long list of every class in the system. Is that wise? Why make it hard for the IDE to help you?

Likewise, say you invented a \inlinecode[blue]{MailingAddress} class in GSD's accounting module, and you named it \inlinecode[red]{GSDAccountAddress}. Later, you need a mailing address for your customer contact application. Do you use \inlinecode[red]{GSDAccountAddress}? Does it sound like the right name? Ten of 17 characters are redundant or irrelevant.

Shorter names are generally better than longer ones, so long as they are clear. Add no more context to a name than is necessary.

The names \inlinecode[green]{accountAddress} and \inlinecode[green]{customerAddress} are fine names for instances of the class \inlinecode[blue]{Address} but could be poor names for classes. \inlinecode[green]{Address} is a fine name for a class. If I need to differentiate between MAC addresses, port addresses, and Web addresses, I might
consider \inlinecode[green]{PostalAddress}, \inlinecode[green]{MAC}, and \inlinecode[green]{URI}. The resulting names are more precise, which is the point of all naming.