---
layout: post
title: Docker Basics
tags: [Docker, Virtualization]
category: FINALIZED
color: rgb(43, 164, 78)
feature-img: "assets/img/post-cover/32-cover.png"
thumbnail: "assets/img/post-cover/32-cover.png"
author: QubitPi
excerpt_separator: <!--more-->
---

<!--more-->

* TOC
{:toc}


Concepts
--------

### Volumes

Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. While
[bind mounts](https://docs.docker.com/storage/bind-mounts/) are dependent on the directory structure and OS of the host 
machine, volumes are completely managed by Docker. Volumes have several advantages over bind mounts:

* Volumes are easier to back up or migrate than bind mounts.
* You can manage volumes using Docker CLI commands or the Docker API.
* Volumes work on both Linux and Windows containers.
* Volumes can be more safely shared among multiple containers.
* Volume drivers let you store volumes on remote hosts or cloud providers, to encrypt the contents of volumes, or to add 
  other functionality.
* New volumes can have their content pre-populated by a container.
* Volumes on Docker Desktop have much higher performance than bind mounts from Mac and Windows hosts.

In addition, volumes are often a better choice than persisting data in a containerâ€™s writable layer, because a volume
does not increase the size of the containers using it, and the volumeâ€™s contents exist outside the lifecycle of a given 
container.

![Error loading types-of-mounts-volume.png]({{ "/assets/img/types-of-mounts-volume.png" | relative_url}})

If your container generates non-persistent state data, consider using a
[tmpfs mount](https://docs.docker.com/storage/tmpfs/) to avoid storing the data anywhere permanently, and to **increase
the container's performance** by avoiding writing into the containerâ€™s writable layer.

Volumes use rprivate bind propagation, and bind propagation is not configurable for volumes.

> ðŸ“‹ **Bind propagation** refers to whether or not mounts created within a given bind-mount can be propagated to
> replicas of that mount. Consider a mount point `/mnt`, which is also mounted on `/tmp`. The propagation settings
> control whether a mount on `/tmp/a` would also be available on `/mnt/a`. Each propagation setting has a recursive 
> counterpoint. In the case of recursion, consider that `/tmp/a` is also mounted as `/foo`. The propagation settings 
> control whether `/mnt/a` and/or `/tmp/a` would exist.
> 
> Meanwhile "**rprivate**" means that any changes to the mount or mounts underneath that mount point are prevented from 
> affecting the host.

#### Create and Manage Volumes

Unlike a bind mount, you can create and manage volumes outside the scope of any container. To create a volume

```bash
docker volume create my-vol
```

To list volumes

```bash
docker volume ls

local               my-vol
```

To inspect a volume:

```bash
docker volume inspect my-vol
[
    {
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/my-vol/_data",
        "Name": "my-vol",
        "Options": {},
        "Scope": "local"
    }
]
```

To remove a volume:

```bash
docker volume rm my-vol
```

#### Start a Container with a Volume

If we start a container with a volume that does not yet exist, Docker creates the volume for us. The following example 
mounts the volume `myvol2` into `/app/` in the container.

```bash
docker run -d --name devtest -v myvol2:/app nginx:latest
```

Use `docker inspect devtest` to verify that the volume was created and mounted correctly. Look for the Mounts section:

```json
"Mounts": [
    {
        "Type": "volume",
        "Name": "myvol2",
        "Source": "/var/lib/docker/volumes/myvol2/_data",
        "Destination": "/app",
        "Driver": "local",
        "Mode": "",
        "RW": true,
        "Propagation": ""
    }
],
```

This shows that the mount is a volume, it shows the correct source and destination, and that the mount is read-write.

Stop the container and remove the volume. Note volume removal is a separate step.

```bash
docker container stop devtest
docker container rm devtest
docker volume rm myvol2
```

#### Use a Volume with docker-compose

A single docker compose service with a volume looks like this:

```yaml
version: "3.9"
services:
  frontend:
    image: node:lts
    volumes:
      - myapp:/home/node/app
volumes:
  myapp:
```

On the first invocation of `docker-compose up` the volume will be created. The same volume will be reused on following 
invocations.

A volume may be created directly outside of compose with docker volume create and then referenced inside
docker-compose.yml as follows:

```yaml
version: "3.9"
services:
  frontend:
    image: node:lts
    volumes:
      - myapp:/home/node/app
volumes:
  myapp:
    external: true
```

For more information about using volumes with compose see
[the compose reference](https://docs.docker.com/compose/compose-file/compose-file-v3/#volume-configuration-reference).

#### Start a Service with Volumes




Docker cAdvisor
---------------

[cAdvisor](https://github.com/google/cadvisor) (Container Advisor) provides Docker container users an understanding of
the resource usage and performance characteristics of their running containers. It is a running daemon that collects, 
aggregates, processes, and exports information about running containers. Specifically, for each container it keeps 
resource isolation parameters, historical resource usage, histograms of complete historical resource usage and network 
statistics. This data is exported by container and machine-wide.

Although [cAdvisor](https://github.com/google/cadvisor) has some prelimilary (useful though) UI. It also offers

1. [RESTful API to query container stats](https://github.com/google/cadvisor/blob/master/docs/api.md)
2. [Export capability to common data storage, such as Elasticsearch](https://github.com/google/cadvisor/blob/master/docs/storage/README.md)

To pull the image and run it:

    sudo docker run   --volume=/:/rootfs:ro   --volume=/var/run/docker.sock:/var/run/docker.sock:rw  --volume=/sys:/sys:ro   --volume=/var/lib/docker/:/var/lib/docker:ro   --volume=/dev/disk/:/dev/disk:ro   --publish=8080:8080   --detach=true   --name=cadvisor   --privileged   --device=/dev/kmsg   gcr.io/cadvisor/cadvisor:v0.36.0

![cAdvisor Screenshot 1]({{ "/assets/img/cadvisor-1.png" | relative_url}})
![cAdvisor Screenshot 2]({{ "/assets/img/cadvisor-2.png" | relative_url}})

### [docker-container-stats](https://github.com/virtualzone/docker-container-stats)

[cAdvisor](https://github.com/google/cadvisor) is good for customizing container monitoring, but it's heavy. A
quick-and-lightweight option would be [docker-container-stats](https://github.com/virtualzone/docker-container-stats)

![docker-container-stats Screenshot]({{ "/assets/img/docker-container-stats.png" | relative_url}})


Docker Troubleshooting
----------------------

### Container

If a container is **not running**:

```
$ docker ps -a
CONTAINER ID   IMAGE             COMMAND                  CREATED          STATUS                      PORTS     NAMES
234rgfq34tg3   image/name          "â€¦"                18 minutes ago   Exited (1) 18 minutes ago             container-name
```

We can retrospect it using

    docker logs 234rgfq34tg3

or

    docker logs container-name

**To enter in a Docker container** already running with a new TTY, with docker 1.3, there is a new command
[**docker exec**](https://docs.docker.com/engine/reference/commandline/exec/). This allows us to enter a running
container:

    docker exec -it [container-id] bash

> This assumes `bash` is installed on our container. We may run `sh` or whatever interactive shell is installed on the
> container.


### Proxy

```bash
% docker pull ubuntu:latest
Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: request canceled while waiting for
connection (Client.Timeout exceeded while awaiting headers)
```

This usually means you need to setup proxy on your local machine. Ignoring all details about proxy, you need to make
the following Docker Desktop configuration. To do it(on Mac), click the little Docker logo on the top bar of your
screen. Click "Resources" and then hit "PROXIES" in the dropdown menu. You should see a configuration window like the
following:

![Error loading docker-proxy-config.png]({{ "/assets/img/docker-proxy-config.png" | relative_url}})

Note that configuring proxy in `~/.bashrc` is not the same thing as doing the config above. Docker Desktop doesn't look
at the `~/.bashrc` for proxy settings.
