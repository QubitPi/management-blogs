---
layout: post
title: HK2 - Dependency Injection Kernel
tags: [Jersey, Dependency Injection, HK2]
color: rgb(8, 86, 112)
feature-img: "assets/img/post-cover/29-cover.png"
thumbnail: "assets/img/post-cover/29-cover.png"
author: QubitPi
excerpt_separator: <!--more-->
---

HK2 is an implementation of JSR-330 in a JavaSE environment. JSR-330 defines services and injection points that can be 
dynamically discovered at runtime and which allow for Inversion of Control (IoC) and dependency injection (DI).

<!--more-->

* TOC
{:toc}

HK2 provides an API for control over its operation and has the ability to automatically load services into the
container. It is the foundation for the GlassFish V3 and V4 application servers as well as other products.

HK2 also has powerful features that can be used to perform tasks such as looking up services or customizing you injections,
as well as several extensibility features allowing the users to connect with other container technologies

The following list gives an overview of some of the things that can be customized or extended with HK2:

* Custom lifecycles and scopes
* Events
* AOP and other proxies
* Custom injection resolution
* Assisted injection
* Just In Time injection resolution
* Custom validation and security
* Run Level Services

Introduction to HK2
-------------------

HK2 2.0 API, which is based on [JSR-330](https://qubitpi.github.io/jersey-guide/2022/06/27/jsr-330.html) standard annotations, is a declarative framework for services using annotations like Contract and Service. 

### Getting Started

In order to mark a concrete implementation class as one that should be available as a service you annotate your class
with [**`@Service`**](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Service.html).

```java
@Service
public class Foo {

    ...
}
```

By default `Foo` will be advertised as itself and by any interfaces that are marked with
[**`@Contract`**](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Contract.html). Lets make `Foo` an 
interface that is a Contract and create an implementation of `Foo`:

```java
@Contract
public interface Foo {
    
    ...
}
```

```java
@Service
public class FooImpl implements Foo {
    
    ...
}
```

The `FooImpl` class will be placed into the registry advertised under both `FooImpl` and `Foo`.

### Named Services

In order to differentiate different implementations of the same interface you can name your services. Here is an example
of a class that implements a contract and has two implementations, both named differently:

```java
@Contract
public interface Book {
    
    ...
}
```

```java
@Named
@Service
public class MobyDick implements Book {
    
    ...
}
```

```java
@Named
@Service
public class ParadiseLost implements Book {
    
    ...
}
```

The two classes, MobyDick and ParadiseLost, will be added to the service registry with the names "MobyDick" and 
"ParadiseLost". If you use the [Named qualifier](https://qubitpi.github.io/jersey-guide/2022/06/27/jsr-330.html#named) 
without specifying a name then the name you get is the class name without the package.


