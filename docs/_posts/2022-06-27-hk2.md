---
layout: post
title: HK2 - Dependency Injection Kernel
tags: [Jersey, Dependency Injection, HK2]
color: rgb(8, 86, 112)
feature-img: "assets/img/post-cover/29-cover.png"
thumbnail: "assets/img/post-cover/29-cover.png"
author: QubitPi
excerpt_separator: <!--more-->
---

HK2 is an implementation of JSR-330 in a JavaSE environment. JSR-330 defines services and injection points that can be 
dynamically discovered at runtime and which allow for Inversion of Control (IoC) and dependency injection (DI).

<!--more-->

* TOC
{:toc}

HK2 provides an API for control over its operation and has the ability to automatically load services into the
container. It is the foundation for the GlassFish V3 and V4 application servers as well as other products.

HK2 also has powerful features that can be used to perform tasks such as looking up services or customizing you injections,
as well as several extensibility features allowing the users to connect with other container technologies

The following list gives an overview of some of the things that can be customized or extended with HK2:

* Custom lifecycles and scopes
* Events
* AOP and other proxies
* Custom injection resolution
* Assisted injection
* Just In Time injection resolution
* Custom validation and security
* Run Level Services

Introduction to HK2
-------------------

HK2 2.0 API, which is based on [JSR-330](https://qubitpi.github.io/jersey-guide/2022/06/27/jsr-330.html) standard annotations, is a declarative framework for services using annotations like Contract and Service. 

### Getting Started

In order to mark a concrete implementation class as one that should be available as a service you annotate your class
with [**`@Service`**](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Service.html).

```java
@Service
public class Foo {

    ...
}
```

By default `Foo` will be advertised as itself and by any interfaces that are marked with
[**`@Contract`**](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Contract.html). Lets make `Foo` an 
interface that is a Contract and create an implementation of `Foo`:

```java
@Contract
public interface Foo {
    
    ...
}
```

```java
@Service
public class FooImpl implements Foo {
    
    ...
}
```

The `FooImpl` class will be placed into the registry advertised under both `FooImpl` and `Foo`.

### Named Services

In order to differentiate different implementations of the same interface you can name your services. Here is an example
of a class that implements a contract and has two implementations, both named differently:

```java
@Contract
public interface Book {
    
    ...
}
```

```java
@Named
@Service
public class MobyDick implements Book {
    
    ...
}
```

```java
@Named
@Service
public class ParadiseLost implements Book {
    
    ...
}
```

The two classes, MobyDick and ParadiseLost, will be added to the service registry with the names "MobyDick" and 
"ParadiseLost". If you use the [Named qualifier](https://qubitpi.github.io/jersey-guide/2022/06/27/jsr-330.html#named) 
without specifying a name then the name you get is the class name without the package.

### Qualified Services

Services can also be qualified with annotations called qualifiers. Qualifiers are annotations that are themselves 
annotated with [`@Qualifier`](https://qubitpi.github.io/jersey-guide/2022/06/27/jsr-330.html#qualifier). Here is an
example contract with three implementations:

```java
@Contract
public interface Color {
    
    ...
}
```

```java
@Blue
@Service
public class BlueColor implements Color {
    
    ..
}
```

```java
@Red
@Service
public class RedColor implements Color {
    
    ...
}
```

```java
@Yellow
@Service
public class YellowColor implements Color {
    
    ...
}
```

The Blue annotation, for example, is defined like this:

```java
@Qualifier
@Retention(RUNTIME)
@Target({ TYPE, METHOD, FIELD, PARAMETER })
public @interface Blue { }
```

The `@Red` and `@Yellow` annotations are defined similarly.

### Basic Injection

Lets make our example a little more interesting by injecting a book into Foo. This is done using the JSR-330 standard 
[Inject](https://qubitpi.github.io/jersey-guide/2022/06/27/jsr-330.html#inject) annotation:

```java
@Service
public class FooImpl implements Foo {
    
    @Inject 
    private Book book;
    
    ...
}
```

Upon construction the book field will be filled in by HK2. You can also inject into the constructor of FooImpl, or use
an initializer method. In both of those cases the constructor or method must be annotated with
[`@Inject`](https://qubitpi.github.io/jersey-guide/2022/06/27/jsr-330.html#inject) in order to tell HK2 which is the proper constructor or method to call.

Here is `FooImpl` implemented with constructor injection:

```java
@Service
public class FooImpl implements Foo {

    private final Book book;

    @Inject
    public FooImpl(Book book) {
        // constructor injected!
        this.book = book;
    }
}
```

Here is FooImpl implemented with initializer method injection:

```java
@Service
public class FooImpl implements Foo {
    
    private Book book;

    @Inject
    public void setBook(Book book) {
        // initializer method injected!
        this.book = book;
    }
}
```

In all three of the above cases (field injected, constructor injected or initializer method injected) the injection will 
occur prior to the `postConstruct` method of `FooImpl`. In this example we use the injected book in the postConstruct 
method:

```java
@Service
public class FooImpl implements Foo {

    @Inject
    private Book book;

    @PostConstruct
    private void postConstruct() {
        book.doSomething();
    }
}
```

### Injection by Name

The astute observer of our example will have noticed that when injecting a `Book` into `FooImpl` that we never selected 
which book we wanted. That can be fixed by using the
[Named](https://qubitpi.github.io/jersey-guide/2022/06/27/jsr-330.html#named) qualifier at the point of injection. Lets 
fix the example by injecting both of the Books we defined earlier:

```java
@Service
public class FooImpl implements Foo {

    @Inject @Named("MobyDick")
    private Book mobyDick;

    @Inject @Named("ParadiseLost")
    private Book paradiseLost;
}
```

The implementation of Book given the name "MobyDick" will be injected into the mobyDick field, and the implementation of 
Book given the name "ParadiseLost" will be injected into the paradiseLost field.

### Injection by Qualifier

Injections can also be more specifically chosen by using qualifiers. In the previous example we created three
implementations of Color, each of which was qualified with a qualifier. Here we create a class called ColorMixer which 
injects the colors in an initializer method, which also demonstrates that an initializer method (or constructor) can
take more than one parameter:

```java
@Service
public class ColorMixer {

    private Color red;
    private Color blue;
    private Color yellow;

    @Inject
    private void addPrimaries(@Red Color red, @Blue Color blue, @Yellow Color yellow) {
        this.red = red;
        this.blue = blue;
        this.yellow = yellow;
    }
}
```

Note that the qualifiers can go on the parameters of the initializer method addPrimaries. In the above example the 
`RedColor`, `BlueColor`, and `YellowColor` services will be injected into the proper fields of the initializer.

### Provider Injection

There are times when your code would like **finer control over when a instance of a service is created**. Anywhere that 
you can inject a service, you can also inject a
[`Provider`](https://qubitpi.github.io/jersey-guide/2022/06/27/jsr-330.html#provider). When you inject a Provider for a 
service rather than the service itself the system will potentially delay the creation of the service until the `get`
method of the `Provider` has been called.

Lets go back to our ColorMixer example, and inject providers (into fields this time) for our primaries.

```java
@Service
public class ColorMixer {

    @Inject @Red
    private Provider<Color> redProvider;

    @Inject @Blue
    private Provider<Color> blueProvider;

    @Inject @Yellow
    private Provider<Color> yellowProvider;
}
```

This service can then get the color implementations later. In this method of ColorMixer we create purple by getting the 
red and blue colors:

```java
@Service
public class ColorMixer {
    
    ...

    public Color makePurple() {
        return mix(redProvider.get(), blueProvider.get());
    }
}
```

Note that if no-one ever makes a color that involves using yellow, that the `YellowColor` implementation class will
never be created, since no-one ever called the `get` method of the `yellowProvider` field.

The value passed into any [`Provider`](https://qubitpi.github.io/jersey-guide/2022/06/27/jsr-330.html#provider)
injection point will be an instance of
[`IterableProvider`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/IterableProvider.html).

### IterableProvider Injection

It is often the case that a single contract has more than one implementation. Sometimes it is useful to get access to
all of the implementations of the contract. This can be done by using an
[`IterableProvider`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/IterableProvider.html).
`IterableProvider` extends `Provider` and also implements `Iterable`. Anywhere a service can be injected an 
`IterableProvider` for that service can be injected.

In this example we create a Library service that wants to be able to list all of the books it carries:

```java
@Service
public class Library {

    @Inject
    private IterableProvider<Book> allBooks;

    public LinkedList<Book> getAllBooks() {
        LinkedList<Book> retVal = new LinkedList<Book>();

        for (Book book : allBooks) {
            retVal.add(book);
        }

        return retVal;
    }
}
```

Since `IterableProvider` implements `Iterable` it can be used in Java for/while loops, as demonstrated in the example
above.

Another feature of the `IterableProvider` is that it can be used to further narrow down the selection criteria at run 
time. In our above example we can programmatically choose the book we are interested in based on a name passed into a 
method. Here is how it would look:

```java
@Service
public class Library {

    @Inject
    private IterableProvider<Book> allBooks;

    public Book findBook(String name) {
        return allBooks.named(name).get();
    }
}
```

In the above example we call the
[`named`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/IterableProvider.html#named-java.lang.String-)
method in `IterableProvider` in order to select the book with the given name. The call to get then just returns the book 
with the given name.

### Iterable injection

[`Iterable`](http://docs.oracle.com/javase/6/docs/api/java/lang/Iterable.html) can be used as an injection point rather 
than [IterableProvider](#iterable-injection). The following code will work as expected:

```java
@Service
public class Library {

    @Inject
    private Iterable<Book> allBooks;

    public LinkedList<Book> getAllBooks() {
        LinkedList<Book> retVal = new LinkedList<Book>();

        for (Book book : allBooks) {
            retVal.add(book);
        }

        return retVal;
    }
}
```

The value passed into any `Iterable` injection point will be an instance of `IterableProvider`.

Getting Started
---------------

### Maven Build

The best way to use HK2 in your builds is to add the following dependency in your maven build:

```xml
<project>
    ...
    
    <dependencies>
        <dependency>
            <groupId>org.glassfish.hk2</groupId>
            <artifactId>hk2</artifactId>
            <version>2.5.0-b36</version>
        </dependency>
    </dependencies>
</project>
```

The org.glassfish.hk2:hk2 dependency has a dependency on all of the HK2 jars. However, this may be more than you want, 
since it includes configuration, run-level services and some osgi support that your application may not need. If instead 
you wanted the absolute minimum working profile for hk2 you would instead have your project look like this:

```xml
<project>
    ...

    <dependencies>
        <dependency>
            <groupId>org.glassfish.hk2</groupId>
            <artifactId>hk2-locator</artifactId>
            <version>2.5.0-b36</version>
        </dependency>
    </dependencies>
</project>
```

The hk2-locator project contains the implementation of the hk2 API, with no other bells and whistles. In particular, the 
ability to automatically detect services is not available, and so all HK2 objects must be added programmatically and 
gotten with the HK2 API. However, the above is perfect for small projects that want to play with the HK2 API to see how
it works.

### Automatic Service Population

In order for HK2 to automatically find services at runtime it can read files called **inhabitant files**. These are 
usually placed in your JAR file at location META-INF/hk2-locator. Normally the file is named "default". (You can however 
use a different file name or location(s) by using more specific API). HK2 has a tool for automatically creating these 
files based on class files annotated with
[`@Service`](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Service.html). There is also a simple API
for creating and populating a
[`ServiceLocator`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/ServiceLocator.html) with services found
in these files.

In order to have your Maven build generate the META-INF files that hk2 reads in order to populate a
[`ServiceLocator`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/ServiceLocator.html) use the 
[hk2-inhabitant-generator](#inhabitant-generators). This tool can be used from the command line, or it can be put
into your maven or ant builds.

In order to have your program automatically load the files generated with the hk2-inhabitant-generator you can use the 
[createAndPopulateServiceLocator](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/utilities/ServiceLocatorUtilities.html#createAndPopulateServiceLocator())
method near the start of your main method, like this:

```java
public static void main(String argv[]) {

        ServiceLocator locator = ServiceLocatorUtilities.createAndPopulateServiceLocator();

        MyService myService = locator.getService(MyService.class);

        ...
}
```

#### Inhabitant Generators

There are two ways to generate hk2 metadata (called inhabitant files) that can be used by the runtime system to find hk2 
services without having to classload those services. The first is the **HK2 Metadata Generator**, which works with the 
javac build tool, and the second is the **HK2 Inhabitant Generator** which can be used at build time with any build
system or even post build time with JARs or can be embedded in other tools.

The HK2 Metadata Generator is easy to use, as all it requires is to be on the javac classpath. The HK2 Inhabitant 
Generator is also easy to use but requires the user to specify lines in the build system files (besides just
dependencies). Users can choose whichever tool works for them in their build environment.

##### HK2 Metadata Generator

The HK2 Metadata Generator will generate hk2 inhabitant files during the compilation of your java files. It is a JSR-269 
annotation processor that handles the
[`@Service`](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Service.html) annotation. The only
requirement for using it is to put the javax.inject, hk2-utils, hk2-api and hk2-metadata-generator libraries in the 
classpath of the javac process.

In this example we use the HK2 Metadata Generator in a Maven based build system:

```xml
<dependency>
    <groupId>org.glassfish.hk2</groupId>
    <artifactId>hk2-metadata-generator</artifactId>
</dependency>
```

Since Maven uses transitive dependencies this is all you need to add as a dependency during build.

###### HK2 Metadata Generator Options

By default the HK2 Metadata Generator places the output file in "META-INF/hk2-locator/default". However this behavior
can be modified by setting the option org.glassfish.hk2.metadata.location to the desired location. This is done with the 
javac compiler using the -A option. 