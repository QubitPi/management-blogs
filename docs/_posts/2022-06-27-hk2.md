---
layout: post
title: HK2 - Dependency Injection Kernel
tags: [Jersey, Dependency Injection, HK2]
color: rgb(8, 86, 112)
feature-img: "assets/img/post-cover/29-cover.png"
thumbnail: "assets/img/post-cover/29-cover.png"
author: QubitPi
excerpt_separator: <!--more-->
---

HK2 is an implementation of JSR-330 in a JavaSE environment. JSR-330 defines services and injection points that can be 
dynamically discovered at runtime and which allow for Inversion of Control (IoC) and dependency injection (DI).

<!--more-->

* TOC
{:toc}

[HK2](https://javaee.github.io/hk2/) provides an API for control over its operation and has the ability to automatically 
load services into the container. It is the foundation for the GlassFish V3 and V4 application servers as well as other 
products.

HK2 also has powerful features that can be used to perform tasks such as looking up services or customizing you injections,
as well as several extensibility features allowing the users to connect with other container technologies

The following list gives an overview of some of the things that can be customized or extended with HK2:

* Custom lifecycles and scopes
* Events
* AOP and other proxies
* Custom injection resolution
* Assisted injection
* Just In Time injection resolution
* Custom validation and security
* Run Level Services

Introduction to HK2
-------------------

HK2 2.0 API, which is based on [JSR-330](https://qubitpi.github.io/jersey-guide/2022/06/27/jsr-330.html) standard annotations, is a declarative framework for services using annotations like Contract and Service. 

### Getting Started

In order to mark a concrete implementation class as one that should be available as a service you annotate your class
with [**`@Service`**](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Service.html).

```java
@Service
public class Foo {

    ...
}
```

By default `Foo` will be advertised as itself and by any interfaces that are marked with
[**`@Contract`**](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Contract.html). Lets make `Foo` an 
interface that is a Contract and create an implementation of `Foo`:

```java
@Contract
public interface Foo {
    
    ...
}
```

```java
@Service
public class FooImpl implements Foo {
    
    ...
}
```

The `FooImpl` class will be placed into the registry advertised under both `FooImpl` and `Foo`.

### Named Services

In order to differentiate different implementations of the same interface you can name your services. Here is an example
of a class that implements a contract and has two implementations, both named differently:

```java
@Contract
public interface Book {
    
    ...
}
```

```java
@Named
@Service
public class MobyDick implements Book {
    
    ...
}
```

```java
@Named
@Service
public class ParadiseLost implements Book {
    
    ...
}
```

The two classes, MobyDick and ParadiseLost, will be added to the service registry with the names "MobyDick" and 
"ParadiseLost". If you use the [Named qualifier](https://qubitpi.github.io/jersey-guide/2022/06/27/jsr-330.html#named) 
without specifying a name then the name you get is the class name without the package.

### Qualified Services

Services can also be qualified with annotations called qualifiers. Qualifiers are annotations that are themselves 
annotated with [`@Qualifier`](https://qubitpi.github.io/jersey-guide/2022/06/27/jsr-330.html#qualifier). Here is an
example contract with three implementations:

```java
@Contract
public interface Color {
    
    ...
}
```

```java
@Blue
@Service
public class BlueColor implements Color {
    
    ..
}
```

```java
@Red
@Service
public class RedColor implements Color {
    
    ...
}
```

```java
@Yellow
@Service
public class YellowColor implements Color {
    
    ...
}
```

The Blue annotation, for example, is defined like this:

```java
@Qualifier
@Retention(RUNTIME)
@Target({ TYPE, METHOD, FIELD, PARAMETER })
public @interface Blue { }
```

The `@Red` and `@Yellow` annotations are defined similarly.

### Basic Injection

Lets make our example a little more interesting by injecting a book into Foo. This is done using the JSR-330 standard 
[Inject](https://qubitpi.github.io/jersey-guide/2022/06/27/jsr-330.html#inject) annotation:

```java
@Service
public class FooImpl implements Foo {
    
    @Inject 
    private Book book;
    
    ...
}
```

Upon construction the book field will be filled in by HK2. You can also inject into the constructor of FooImpl, or use
an initializer method. In both of those cases the constructor or method must be annotated with
[`@Inject`](https://qubitpi.github.io/jersey-guide/2022/06/27/jsr-330.html#inject) in order to tell HK2 which is the proper constructor or method to call.

Here is `FooImpl` implemented with constructor injection:

```java
@Service
public class FooImpl implements Foo {

    private final Book book;

    @Inject
    public FooImpl(Book book) {
        // constructor injected!
        this.book = book;
    }
}
```

Here is FooImpl implemented with initializer method injection:

```java
@Service
public class FooImpl implements Foo {
    
    private Book book;

    @Inject
    public void setBook(Book book) {
        // initializer method injected!
        this.book = book;
    }
}
```

In all three of the above cases (field injected, constructor injected or initializer method injected) the injection will 
occur prior to the `postConstruct` method of `FooImpl`. In this example we use the injected book in the postConstruct 
method:

```java
@Service
public class FooImpl implements Foo {

    @Inject
    private Book book;

    @PostConstruct
    private void postConstruct() {
        book.doSomething();
    }
}
```

### Injection by Name

The astute observer of our example will have noticed that when injecting a `Book` into `FooImpl` that we never selected 
which book we wanted. That can be fixed by using the
[Named](https://qubitpi.github.io/jersey-guide/2022/06/27/jsr-330.html#named) qualifier at the point of injection. Lets 
fix the example by injecting both of the Books we defined earlier:

```java
@Service
public class FooImpl implements Foo {

    @Inject @Named("MobyDick")
    private Book mobyDick;

    @Inject @Named("ParadiseLost")
    private Book paradiseLost;
}
```

The implementation of Book given the name "MobyDick" will be injected into the mobyDick field, and the implementation of 
Book given the name "ParadiseLost" will be injected into the paradiseLost field.

### Injection by Qualifier

Injections can also be more specifically chosen by using qualifiers. In the previous example we created three
implementations of Color, each of which was qualified with a qualifier. Here we create a class called ColorMixer which 
injects the colors in an initializer method, which also demonstrates that an initializer method (or constructor) can
take more than one parameter:

```java
@Service
public class ColorMixer {

    private Color red;
    private Color blue;
    private Color yellow;

    @Inject
    private void addPrimaries(@Red Color red, @Blue Color blue, @Yellow Color yellow) {
        this.red = red;
        this.blue = blue;
        this.yellow = yellow;
    }
}
```

Note that the qualifiers can go on the parameters of the initializer method addPrimaries. In the above example the 
`RedColor`, `BlueColor`, and `YellowColor` services will be injected into the proper fields of the initializer.

### Provider Injection

There are times when your code would like **finer control over when a instance of a service is created**. Anywhere that 
you can inject a service, you can also inject a
[`Provider`](https://qubitpi.github.io/jersey-guide/2022/06/27/jsr-330.html#provider). When you inject a Provider for a 
service rather than the service itself the system will potentially delay the creation of the service until the `get`
method of the `Provider` has been called.

Lets go back to our ColorMixer example, and inject providers (into fields this time) for our primaries.

```java
@Service
public class ColorMixer {

    @Inject @Red
    private Provider<Color> redProvider;

    @Inject @Blue
    private Provider<Color> blueProvider;

    @Inject @Yellow
    private Provider<Color> yellowProvider;
}
```

This service can then get the color implementations later. In this method of ColorMixer we create purple by getting the 
red and blue colors:

```java
@Service
public class ColorMixer {
    
    ...

    public Color makePurple() {
        return mix(redProvider.get(), blueProvider.get());
    }
}
```

Note that if no-one ever makes a color that involves using yellow, that the `YellowColor` implementation class will
never be created, since no-one ever called the `get` method of the `yellowProvider` field.

The value passed into any [`Provider`](https://qubitpi.github.io/jersey-guide/2022/06/27/jsr-330.html#provider)
injection point will be an instance of
[`IterableProvider`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/IterableProvider.html).

### IterableProvider Injection

It is often the case that a single contract has more than one implementation. Sometimes it is useful to get access to
all of the implementations of the contract. This can be done by using an
[`IterableProvider`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/IterableProvider.html).
`IterableProvider` extends `Provider` and also implements `Iterable`. Anywhere a service can be injected an 
`IterableProvider` for that service can be injected.

In this example we create a Library service that wants to be able to list all of the books it carries:

```java
@Service
public class Library {

    @Inject
    private IterableProvider<Book> allBooks;

    public LinkedList<Book> getAllBooks() {
        LinkedList<Book> retVal = new LinkedList<Book>();

        for (Book book : allBooks) {
            retVal.add(book);
        }

        return retVal;
    }
}
```

Since `IterableProvider` implements `Iterable` it can be used in Java for/while loops, as demonstrated in the example
above.

Another feature of the `IterableProvider` is that it can be used to further narrow down the selection criteria at run 
time. In our above example we can programmatically choose the book we are interested in based on a name passed into a 
method. Here is how it would look:

```java
@Service
public class Library {

    @Inject
    private IterableProvider<Book> allBooks;

    public Book findBook(String name) {
        return allBooks.named(name).get();
    }
}
```

In the above example we call the
[`named`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/IterableProvider.html#named-java.lang.String-)
method in `IterableProvider` in order to select the book with the given name. The call to get then just returns the book 
with the given name.

### Iterable injection

[`Iterable`](http://docs.oracle.com/javase/6/docs/api/java/lang/Iterable.html) can be used as an injection point rather 
than [IterableProvider](#iterable-injection). The following code will work as expected:

```java
@Service
public class Library {

    @Inject
    private Iterable<Book> allBooks;

    public LinkedList<Book> getAllBooks() {
        LinkedList<Book> retVal = new LinkedList<Book>();

        for (Book book : allBooks) {
            retVal.add(book);
        }

        return retVal;
    }
}
```

The value passed into any `Iterable` injection point will be an instance of `IterableProvider`.

Getting Started
---------------

### Maven Build

The best way to use HK2 in your builds is to add the following dependency in your maven build:

```xml
<project>
    ...
    
    <dependencies>
        <dependency>
            <groupId>org.glassfish.hk2</groupId>
            <artifactId>hk2</artifactId>
            <version>2.5.0-b36</version>
        </dependency>
    </dependencies>
</project>
```

The org.glassfish.hk2:hk2 dependency has a dependency on all of the HK2 jars. However, this may be more than you want, 
since it includes configuration, run-level services and some osgi support that your application may not need. If instead 
you wanted the absolute minimum working profile for hk2 you would instead have your project look like this:

```xml
<project>
    ...

    <dependencies>
        <dependency>
            <groupId>org.glassfish.hk2</groupId>
            <artifactId>hk2-locator</artifactId>
            <version>2.5.0-b36</version>
        </dependency>
    </dependencies>
</project>
```

The hk2-locator project contains the implementation of the hk2 API, with no other bells and whistles. In particular, the 
ability to automatically detect services is not available, and so all HK2 objects must be added programmatically and 
gotten with the HK2 API. However, the above is perfect for small projects that want to play with the HK2 API to see how
it works.

### Automatic Service Population

In order for HK2 to automatically find services at runtime it can read files called **inhabitant files**. These are 
usually placed in your JAR file at location META-INF/hk2-locator. Normally the file is named "default". (You can however 
use a different file name or location(s) by using more specific API). HK2 has a tool for automatically creating these 
files based on class files annotated with
[`@Service`](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Service.html). There is also a simple API
for creating and populating a
[`ServiceLocator`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/ServiceLocator.html) with services found
in these files.

In order to have your Maven build generate the META-INF files that hk2 reads in order to populate a
[`ServiceLocator`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/ServiceLocator.html) use the 
[hk2-inhabitant-generator](#inhabitant-generators). This tool can be used from the command line, or it can be put
into your maven or ant builds.

In order to have your program automatically load the files generated with the hk2-inhabitant-generator you can use the 
[createAndPopulateServiceLocator](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/utilities/ServiceLocatorUtilities.html#createAndPopulateServiceLocator())
method near the start of your main method, like this:

```java
public static void main(String argv[]) {

        ServiceLocator locator = ServiceLocatorUtilities.createAndPopulateServiceLocator();

        MyService myService = locator.getService(MyService.class);

        ...
}
```

#### Inhabitant Generators

There are two ways to generate hk2 metadata (called inhabitant files) that can be used by the runtime system to find hk2 
services without having to classload those services. The first is the **HK2 Metadata Generator**, which works with the 
javac build tool, and the second is the **HK2 Inhabitant Generator** which can be used at build time with any build
system or even post build time with JARs or can be embedded in other tools.

The HK2 Metadata Generator is easy to use, as all it requires is to be on the javac classpath. The HK2 Inhabitant 
Generator is also easy to use but requires the user to specify lines in the build system files (besides just
dependencies). Users can choose whichever tool works for them in their build environment.

##### HK2 Metadata Generator

The HK2 Metadata Generator will generate hk2 inhabitant files during the compilation of your java files. It is a JSR-269 
annotation processor that handles the
[`@Service`](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Service.html) annotation. The only
requirement for using it is to put the javax.inject, hk2-utils, hk2-api and hk2-metadata-generator libraries in the 
classpath of the javac process.

In this example we use the HK2 Metadata Generator in a Maven based build system:

```xml
<dependency>
    <groupId>org.glassfish.hk2</groupId>
    <artifactId>hk2-metadata-generator</artifactId>
</dependency>
```

Since Maven uses transitive dependencies this is all you need to add as a dependency during build.

###### HK2 Metadata Generator Options

By default the HK2 Metadata Generator places the output file in "META-INF/hk2-locator/default". This behavior, however,
can be modified by setting the option `org.glassfish.hk2.metadata.location` to the desired location. This is done with
the javac compiler using the `-A` option. 

##### HK2 Inhabitant Generator

The HK2 Inhabitant Generator is a utility that will generate inhabitants file during the build of your JAR file. It
works by analyzing the classes that have been built by javac and then creating the file "META-INF/hk2-locator/default"
(by default) in your JAR file that has information in it about all of the classes that you have marked with
[`@Service`](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Service.html) or
[`@Contract`](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Contract.html).

The HK2 Inhabitatants Generator can be used as a standalone command-line tool, or it can be embedded in any Java
program. It can also be used in a Maven build. An Eclipse build and an ant task are also planned. Here are the ways that 
the HK2 Inhabitants Generator can be used:

###### Command Line Tool

The HK2 Inhabitants Genertor can be run from the command line like this:

    java org.jvnet.hk2.generator.HabitatGenerator

By default the [`HabibatGenerator`](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/generator/HabitatGenerator.html) 
will attempt to analyze the first element of the classpath and replace that element (if it is a JAR) with a new JAR that 
has an inhabitants file in it describing all of the classes marked with
[`@Service`](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Service.html). If the first element of the 
classpath is a directory it will attempt to create a new inhabitants file in that directory describing all of the classes marked with `@Service`.

You can modify this behavior by using command line options. Here is the usage statement for `HabibatGenerator`:

```
java org.jvnet.hk2.generator.HabitatGenerator
  [--file jarFileOrDirectory]
  [--outjar jarFile]
  [--locator locatorName]
  [--verbose]
```

* The `-file` option allows the user to pick a directory or JAR file to analyze for classes marked with `@Service`.
* The `-outjar` option allows the user to pick the output JAR file that the generator should create with the inhabitants file in it.
* The `-locator` option allows the user to name the locator that these services should go into. This value is "default"
  by default.
* The `-verbose` option make the generator print extra information as it does its work.

This command line utility will call `System.exit` when it is done with a 0 code if it was able to work properly and a 
non-zero value if it failed in some way.

###### Embedded Usage

The class
[`org.jvnet.hk2.generator.HabitatGenerator`](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/generator/HabitatGenerator.html) has a static method on called **`embeddedMain`**. The 
`embeddedMain` takes the typical `argv[]` array of parameters and so has the same behavior as the
[command line usage](#command-line-tool). The biggest difference is that this method returns an `int` as the return
code, either 0 for success or non-zero for failure and does not call `System.exit()`. See the its
[javadoc](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/generator/HabitatGenerator.html) for more information.

Using `embeddedMain` is useful if you want to build your own build tools that generate inhabitants files for your own
IDE or other build environment.

###### Using Maven

The `HabitatGenerator` is also available as a Maven plugin. It has a single goal, called **generateInhabitants** that
is run in the process-classes phase by default. Using this plugin in your build will cause inhabitants files to be 
generated in your output directory.

The following example plugin snippet from a `pom.xml` will run the `InhabitantsGenerator` in both the main tree and in
the test tree, in case you would like your test sources to also be analyzed for classes marked with `@Service`.

```xml
    <plugin>
        <groupId>org.glassfish.hk2</groupId>
        <artifactId>hk2-inhabitant-generator</artifactId>
        <version>2.5.0-b36</version>
        <executions>
            <execution>
                <goals>
                    <goal>generate-inhabitants</goal>
                </goals>
            </execution>
        </executions>
    </plugin>
```

The plugin has the following configuration options:

* `test` Set to `true` if this execution should be for the tests rather than main
* `outputDirectory` (the place the output file will go, defaults to `${project.build.outputDirectory}`)
* `testOutputDirectory` (the place the output will go if test is `true`, defaults to `${project.build.testOutputDirectory}`)
* `verbose` (`true` or `false`)
* locator (The name of the locator file which is "default" by default)
* noswap (`true` or `false`) if set to `true` the generator will overwrite files in place which is riskier but faster

###### Ant Task

The inhabitant generator can also be used as an ant task. The ant task is
`org.jvnet.hk2.generator.maven.ant.HK2InhabitantGeneratorTask`. Below find an example ant file that uses the task:

```xml
<project name="HK2 Ant Build File" default="build" basedir=".">
    <!-- set global properties for this build -->
    <property name="src" location="src"/>
    <property name="build" location="target/classes"/>
  
    <taskdef name="hk2-inhabitant-generator" classname="org.jvnet.hk2.generator.ant.HK2InhabitantGeneratorTask"/>
  
    <target name="compile" >
        <!-- Compile the java code from ${src} into ${build} -->
        <javac srcdir="${src}" destdir="${build}"/>
        <hk2-inhabitant-generator targetDirectory="${build}"/>
    </target>
</project>
```

> 📋 In the example above, the hk2-inhabitant-generator must run after the classes are built, as the
> hk2-inhabitant-generator inspects the class files.

The ant plugin has the following options:

* `targetDirectory` (the directory to find the classes, defaults to target/classes)
* `outputDirectory` (the place the output file will go, defaults to target/classes)
* `verbose` (`true` or `false`)
* locator (The name of the locator file which is "default" by default)
* noswap (`true` or `false`) if set to `true` the generator will overwrite files in place which is riskier but faster

##### Stub Generation

The HK2 metadata generator can also generate implementation classes based on abstract classes. This is useful when 
testing, as it is often the case in tests that the user would like to replace some service with one that does nothing or 
does only a few special things during the test. This is done by putting the Stub annotation on an abstract class. Any 
abstract methods NOT implemented by the class will have dummy implementations generated in a java file that also has an 
Service annotation. This will then become an service in the Singleton scope, which should show up when using most hk2 
initialization methodologies. The benefits of using the Stub annotation include:

* The service need not be completely implemented. Only those methods that need to return specific data needed by the
  test need to be implemented
* The [Rank](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/Rank.html) annotation will work when placed on
  the abstract class, so the stub can be given higher priority than the replacement class
* Using Stub means that this abstract class may not need to be updated if the underlying interface or class has an added 
* method
* It makes it very easy to write very simple test replacement classes

In this simple example there is an interface with a large number of methods:

```java
@Contract
public interface ManyMethodsService { 
    
    void methodA();
    void methodB();
    int methodFoo();
    String methodBar(String input);
}
```

Somewhere in your build there is an implementation of `ManyMethodsService`. It may or may not look like this:

```java
@Service
public class ManyMethodsServiceImpl implements ManyMethodsService {
    
    // Here we really implement the interface, possibly doing JDBC or other possibly heavy operations
}
```

However, in the test environment there is only one or two methods that the test touches. In this case we can very easily 
use the Stub annotation to tell the hk2-metadata-generator to generate an implementation that fills in the missing 
methods. This test version of the service might be implemented like this:

```java
@Stub
@Rank(1)
public abstract class TestManyMethodsService implements ManyMethodsService {

    // Only implement the methods that the test actually touches, and return
    // hard-coded data
    public int methodFoo() {
      return 13;
    }

    public String methodBar(String input) {
      return input;
    }

    // Do not implement the other methods in the interface
}
```

If the hk2-metadata-generator is in the classpath of the test build then it will see the Stub annotation and will
generate a java file with the unimplemented methods implemented, returning either `null` or 0 or "a" along with an added 
Service annotation. Since the Rank annotation is set to 1 in the abstract class (`TestManyMethodsService`) it will be
used in favor of the true implementation (`ManyMethodsServiceImpl`).

If there is a `@Named` qualifier on the class annotated with Stub that qualifier will also be copied to the resulting 
implementation class. If `@Named` has no value associated with it the value used will be the value of the class with
Stub on it. For example this class:

```java
@Stub
@Named
public abstract class AliceService implements SomeInterface {
    
    ...
}
```

will end up having the name "AliceService", while this class:

```java
@Stub
@Named("Bob")
public abstract class AliceService implements SomeInterface {
    
    ...
}
```

will end up having the name "Bob". Only the `@Named` qualifier is treated specially in this way.

The Stub annotation can also generate implementations where rather than returning `null` or zero values it throws 
`UnsupportedOperationException` (with the name of the method called in the message). This can be done by setting the
value field of the Stub to `EXCEPTIONS`, like this:

```java
@Stub(Stub.Type.EXCEPTIONS)
public abstract class AliceService implements SomeInterface {
    
    // All generated methods will throw UnsupportedOperationException
}
```

This can be useful when writing tests to ensure that the code does not inadvertently use one of the methods of the
stub's implementation.

HK2 API
-------

