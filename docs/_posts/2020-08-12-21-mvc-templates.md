---
layout: post
title: MVC Templates
tags: [MVC, Mustache]
color: rgb(146, 168, 209)
author: QubitPi
feature-img: "assets/img/post-cover/21-cover.png"
thumbnail: "assets/img/post-cover/21-cover.png"
excerpt_separator: <!--more-->
---

<!--more-->

Jersey provides an extension to support the Model-View-Controller (MVC) design pattern. In the context of Jersey
components,

* ***the Controller from the MVC pattern corresponds to a resource class or method***,
* ***the View to a template bound to the resource class or method***, and
* ***the model to a Java object (or a Java bean) returned from a resource method (Controller)***.

In Jersey 2, the base MVC API consists of two classes (`org.glassfish.jersey.server.mvc` package) that can be used to
bind model to view (template), namely
***[Viewable](https://eclipse-ee4j.github.io/jersey.github.io/apidocs/snapshot/jersey/org/glassfish/jersey/server/mvc/Viewable.html)***
and
***[@Template](https://eclipse-ee4j.github.io/jersey.github.io/apidocs/snapshot/jersey/org/glassfish/jersey/server/mvc/Template.html)***.
These classes determine which approach (explicit/implicit) you would be taking when working with Jersey MVC templating support.  

* TOC
{:toc}

## Viewable

In this approach a resource method explicitly returns a reference to a view template and the data model to be used. For
this purpose the
[Viewable](https://eclipse-ee4j.github.io/jersey.github.io/apidocs/snapshot/jersey/org/glassfish/jersey/server/mvc/Viewable.html)
class has been introduced in Jersey 1 and is also present (under a different package) in Jersey 2. A simple example of
usage can be seen below

```java
package com.example;
 
@Path("foo")
public class Foo {
 
    @GET
    public Viewable get() {
        return new Viewable("index.foo", "FOO");
    }
}
```

In this example, the `Foo` JAX-RS resource class is the controller and the `Viewable` instance encapsulates the provided
data model (`FOO` string) and a named reference to the associated view template (`index.foo`). 

> ✏️ All HTTP methods may return `Viewable` instances. Thus a POST method may return a template reference to a template
> that produces a view as a result of processing an HTML Form. 

## @Template

### Annotating Resource Methods

There is no need to use `Viewable` every time you want to bind a model to a template. To make the resource method more
readable (and to avoid verbose wrapping of a template reference and model into `Viewable`) you can simply annotate a
resource method with
[@Template](https://eclipse-ee4j.github.io/jersey.github.io/apidocs/snapshot/jersey/org/glassfish/jersey/server/mvc/Template.html)
annotation. An updated example, using `@Template`, from previous section is shown below

```java
package com.example;
 
@Path("foo")
public class Foo {
 
    @GET
    @Template(name = "index.foo")
    public String get() {
        return "FOO";
    }
}
```

In this example, the `Foo` JAX-RS resource class is still the controller as in previous section but the MVC model is now
represented by the return value of annotated resource method.

The processing of such a method is then essentially the same as if the return type of the method was an instance of the
[Viewable](https://eclipse-ee4j.github.io/jersey.github.io/apidocs/snapshot/jersey/org/glassfish/jersey/server/mvc/Viewable.html)
class. ***If a method is annotated with `@Template` and is also returning a `Viewable` instance then the values from the
`Viewable` instance take precedence over those defined in the annotation***. Producible media types are for both cases,
`Viewable` and `@Template`, determined by the method or class level `@Produces` annotation. 

### Annotating Resource Classes

A resource class can have templates implicitly associated with it via
[@Template](https://eclipse-ee4j.github.io/jersey.github.io/apidocs/snapshot/jersey/org/glassfish/jersey/server/mvc/Template.html)
annotation. For example, take a look at the resource class listing below

```java
@Template
@Path("foo")
public class Foo {
 
    public String getFoo() {
        return "FOO";
    }
}
```

The example relies on Jersey MVC conventions a lot and requires more explanation as such.

First of all, you may have noticed that there is no resource method defined in this JAX-RS resource. Also, there is no
template reference defined. In this case, since the `@Template` annotation placed on the resource class does not contain
any information, the default relative template reference index will be used (for more on this topic see Section
[Absolute vs. Relative template reference](#absolute-vs-relative-template-reference)). As for the missing resource
methods, a default `@GET` method will be automatically generated by Jersey for the `Foo` resource (which is the MVC
Controller now). The implementation of the generated resource method performs the equivalent of the following explicit
resource method:

```java
@GET
public Viewable get() {
    return new Viewable("index", this);
}
```

You can see that the resource class serves in this case also as the model. Producible media types are determined based
on the `@Produces` annotation declared on the resource class, if any.

> 📋️ In case of "resource class"-based implicit MVC view templates, the controller is also the model. In such case the
> template reference `index` is special, it is the template reference associated with the controller instance itself. 

In the following example, the MVC controller represented by a JAX-RS `@GET` sub-resource method, is also generated in
the resource class annotated with `@Template`:

```java
@GET
@Path("{implicit-view-path-parameter}")
public Viewable get(@PathParameter("{implicit-view-path-parameter}") String template) {
    return new Viewable(template, this);
}
```

This allows Jersey to support also implicit sub-resource templates. For example, a JAX-RS resource at path `foo/bar`
will try to use relative template reference bar that resolves to an absolute template reference `/com/foo/Foo/bar`.

In other words, a HTTP GET request to a `/foo/bar` would be handled by this auto-generated method in the `Foo` resource
and would delegate the request to a registered template processor supports processing of the absolute template reference
`/com/foo/Foo/bar`, where the model is still an instance of the same JAX-RS resource class Foo. 

## Absolute vs. Relative Template Reference
   
As discussed in the previous section, both
[@Template](https://eclipse-ee4j.github.io/jersey.github.io/apidocs/snapshot/jersey/org/glassfish/jersey/server/mvc/Template.html)
and
[Viewable](https://eclipse-ee4j.github.io/jersey.github.io/apidocs/snapshot/jersey/org/glassfish/jersey/server/mvc/Viewable.html)
provide means to define a reference to a template. We will now discuss how these values are interpreted and how the
concrete template is found.

### Relative Template Reference

Relative reference is any path that does not start with a leading `'/'` (slash) character (i.e. `index.foo`). This kind
of references is resolved into absolute ones by pre-pending a given value with a fully qualified name of the last
matched resource.

Jersey will then search all the registered template processors (see Section
[Writing Custom Templating Engines](#writing-custom-templating-engines)) to find a template processor that can resolve
the absolute template reference further to a "processable" template reference. If a template processor is found then the
"processable" template is processed using the supplied data model.

> 📋️ If none or empty template reference is provided (either in `Viewable` or via `@Template`) then the `index`
> reference is assumed and all further processing is done for this value. 

### Absolute Template Reference

Let's change the resource GET method in our `Foo` resource a little: 

```java
@GET
public Viewable get() {
    return new Viewable("/index", "FOO");
}
```

In this case, ***since the template reference begins with "/", Jersey will consider the reference to be absolute already
and will not attempt to absolutize it again***. The reference will be used "as is" when resolving it to a "processable"
template reference as described earlier.

Absolute template references start with leading '`/`' (i.e. `/com/example/index.foo`) character and are not further
resolved (with respect to the resolving resource class) which means that the template is looked for at the provided path
directly.

Note, however, that template processors for custom templating engines may modify (and the supported ones do) absolute
template reference by pre-pending 'base template path' (if defined) and appending template suffix (i.e. `foo`) if the
suffix is not provided in the reference. 

For example assume that we want to use Mustache templates for our views and we have defined 'base template path' as
pages. For the absolute template reference `/com/example/Foo/index` the template processor will transform the reference
into the following path: `/pages/com/example/Foo/index.mustache`.  

## Handling Errors with MVC

In addition to
[@Template](https://eclipse-ee4j.github.io/jersey.github.io/apidocs/snapshot/jersey/org/glassfish/jersey/server/mvc/Template.html),
the
***[@ErrorTemplate](https://eclipse-ee4j.github.io/jersey.github.io/apidocs/snapshot/jersey/org/glassfish/jersey/server/mvc/ErrorTemplate.html)***
annotation has been introduced in Jersey 2.3 as well. The purpose of this annotation is to bind the model to an error
view in case an exception has been raised during processing of a request. This is true for any exception thrown after
the resource matching phase (i.e. this not only applies to JAX-RS resources but providers and even Jersey runtime as
well). The model in this case is the thrown exception itself.

The next example shows how to use `@ErrorTemplate` on a resource method. If all goes well with the method processing,
then the `/short-link` template is used as page sent to the user. Otherwise, if an exception is raised, the
`/error-form` template is shown to the user.

```java
@POST
@Produces({"text/html”})
@Template(name = "/short-link")
@ErrorTemplate(name = "/error-form")
@Consumes(MediaType.APPLICATION_FORM_URLENCODED)
public ShortenedLink createLink(@FormParam("link") final String link) {
    // ...
}
```

Note that
[@ErrorTemplate](https://eclipse-ee4j.github.io/jersey.github.io/apidocs/snapshot/jersey/org/glassfish/jersey/server/mvc/ErrorTemplate.html)
can be used on a resource class or a resource method to merely handle error states. There is no need to use
[@Template](https://eclipse-ee4j.github.io/jersey.github.io/apidocs/snapshot/jersey/org/glassfish/jersey/server/mvc/Template.html)
or
[Viewable](https://eclipse-ee4j.github.io/jersey.github.io/apidocs/snapshot/jersey/org/glassfish/jersey/server/mvc/Viewable.html)
with it. 

The annotation is handled by custom
***[ExceptionMapper`<E extends Throwable>`](https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/ext/ExceptionMapper.html)***
which creates an instance of `Viewable` that is further processed by Jersey. This exception mapper is registered
automatically with a ***MvcFeature***. 

### MVC & Bean Validation

`@ErrorTemplate` can also be used with Bean Validation to display specific error pages in case the validation of
input/output values fails for some reason. Everything works as described above except the model is not the thrown
exception but rather a list of
***[ValidationError](https://eclipse-ee4j.github.io/jersey.github.io/apidocs/snapshot/jersey/org/glassfish/jersey/server/validation/ValidationError.html)***s.
This list can be iterated in the template and all the validation errors can be shown to the user in a desirable way. 

```java
@POST
@Valid
@Produces({"text/html”})
@Consumes(MediaType.APPLICATION_FORM_URLENCODED)
@Template(name = "/short-link”) @ErrorTemplate(name = "/error-form")
public ShortenedLink createLink(@NotEmpty @FormParam("link") final String link) {
    // ...
}
```

Iterating through ValidationError in JSP:

```html
<c:forEach items="${model}" var="error">
    ${error.message} "<strong>${error.invalidValue}</strong>"<br/>
</c:forEach>
```

Support for Bean Validation in Jersey MVC Templates is provided by a `jersey-mvc-bean-validation` extension module. The
JAX-RS [Feature](https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/core/Feature.html) provided by this
module (`MvcBeanValidationFeature`) has to be registered in order to use this functionality (see Section
[Registration and Configuration](#registration-and-configuration)).

Maven users can find this module at coordinates 

```xml
<dependency>
    <groupId>org.glassfish.jersey.ext</groupId>
    <artifactId>jersey-mvc-bean-validation</artifactId>
    <version>2.31</version>
</dependency>
```

and for non-Maven users the list of dependencies is available at
[jersey-mvc-bean-validation](https://eclipse-ee4j.github.io/jersey.github.io/project-info/2.31/jersey/project/jersey-mvc-bean-validation/dependencies.html).

## Registration and Configuration

To use the capabilities of Jersey MVC templating support in your JAX-RS/Jersey application you need to register specific
JAX-RS [Feature](https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/core/Feature.html)s provided by the
MVC modules. For `jersey-mvc` module it is
[MvcFeature](https://eclipse-ee4j.github.io/jersey.github.io/apidocs/snapshot/jersey/org/glassfish/jersey/server/mvc/MvcFeature.html)
for others it could be, for example,
[FreemarkerMvcFeature](https://eclipse-ee4j.github.io/jersey.github.io/apidocs/snapshot/jersey/org/glassfish/jersey/server/mvc/freemarker/FreemarkerMvcFeature.html)
(`jersey-mvc-freemarker`).

```java
// Registering MvcFeature
new ResourceConfig()
        .register(org.glassfish.jersey.server.mvc.MvcFeature.class)
        .register( ... );
``` 

```java
// Registering FreemarkerMvcFeature
new ResourceConfig()
        .register(org.glassfish.jersey.server.mvc.freemarker.FreemarkerMvcFeature.class)
        .register( ... );
```

> 📋️ Modules that uses capabilities of the base Jersey MVC module register `MvcFeature` automatically, so you don't need
> to register this feature explicitly in your code.

Almost all of the MVC modules are further configurable and either contain a `*Properties` (e.g.
`FreemarkerMvcProperties`) class describing all the available properties which could be set in a JAX-RS
`Application`/`ResourceConfig`. Alternatively, the properties are listed directly in the module `*Feature` class.

```java
new ResourceConfig()
        .property(MvcFeature.TEMPLATE_BASE_PATH, "templates")
        .register(MvcFeature.class)
        .register( ... );
``` 

```xml
<servlet>
    <servlet-name>org.glassfish.jersey.examples.freemarker.MyApplication</servlet-name>
    <servlet-class>org.glassfish.jersey.servlet.ServletContainer</servlet-class>
    <init-param>
        <param-name>javax.ws.rs.Application</param-name>
        <param-value>org.glassfish.jersey.examples.freemarker.MyApplication</param-value>
    </init-param>
    <init-param>
        <param-name>jersey.config.server.mvc.templateBasePath.freemarker</param-name>
        <param-value>freemarker</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
```

## Supported Templating Engines

Jersey provides extension modules that enable support for several templating engines. This section lists all the
supported engines and their modules as well as discusses any module-specific details. 

### Mustache

***[Mustache](https://github.com/spullara/mustache.java)*** template processor resolves absolute template references to
processable template references represented as ***Mustache templates*** as follows:

1. if the absolute template reference does not end in `.mustache` append this suffix to the reference; and
2. if `ServletContext.getResource`, `Class.getResource`, or `File.exists` returns a non-`null` value for the reference
   then return the reference as the processable template reference otherwise return `null` (to indicate the absolute
   reference has not been resolved by the Mustache template processor).
   
Thus the absolute template reference `/com/foo/Foo/index` would be resolved as `/com/foo/Foo/index.mustache`, provided
there exists a `/com/foo/Foo/index.mustache` Mustache template in the application.  

Available configuration properties:

* `MustacheMvcFeature.TEMPLATE_BASE_PATH - jersey.config.server.mvc.templateBasePath.mustache`: The base path where
   Mustache templates are located.
* `MustacheMvcFeature.CACHE_TEMPLATES - jersey.config.server.mvc.caching.mustache`: Enables caching of Mustache
  templates to avoid multiple compilation.
* `MustacheMvcFeature.TEMPLATE_OBJECT_FACTORY - jersey.config.server.mvc.factory.mustache`: Property used to pass
  user-configured `MustacheFactory`.
* `MustacheMvcFeature.ENCODING - jersey.config.server.mvc.encoding.mustache` - Property used to configure a default
  encoding that will be used if none is specified in
  [@Produces](https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/Produces.html) annotation. If property
  is not defined the UTF-8 encoding will be used as a default value.
  
Maven users can find this module at coordinates 

```xml
<dependency>
    <groupId>org.glassfish.jersey.ext</groupId>
    <artifactId>jersey-mvc-mustache</artifactId>
    <version>2.31</version>
</dependency>
```

and for non-Maven users the list of dependencies is available at
[jersey-mvc-mustache](https://eclipse-ee4j.github.io/jersey.github.io/project-info/2.31/jersey/project/jersey-mvc-mustache/dependencies.html).

### Freemarker

***[Freemarker](https://freemarker.apache.org/)*** template processor resolves absolute template references to
processable template references represented as Freemarker templates as follows:

1. if the absolute template reference does not end in `.ftl` append this suffix to the reference; and
2. if `ServletContext.getResource`, `Class.getResource` or `File.exists` returns a non-`null` value for the reference
   then return the reference as the processable template reference otherwise return `null` (to indicate the absolute
   reference has not been resolved by the Freemarker template processor). 

Thus the absolute template reference `/com/foo/Foo/index` would be resolved to `/com/foo/Foo/index.ftl`, provided there
exists a `/com/foo/Foo/index.ftl` Freemarker template in the application.

Jersey will assign the model instance to an attribute named `model`. So it is possible to reference the `foo` key from
the provided `Map` (MVC Model) resource from the Freemarker template as follows:

```html
<h1>${model.foo}</h1>
```

Available configuration properties:

* `FreemarkerMvcFeature.TEMPLATE_BASE_PATH - jersey.config.server.mvc.templateBasePath.freemarker`: The base path where
  Freemarker templates are located.
* `FreemarkerMvcFeature.CACHE_TEMPLATES - jersey.config.server.mvc.caching.freemarker`: Enables caching of Freemarker
  templates to avoid multiple compilation.
* `FreemarkerMvcFeature.TEMPLATE_OBJECT_FACTORY - jersey.config.server.mvc.factory.freemarker`: Property used to pass
  user-configured `FreemarkerFactory`.
* `FreemarkerMvcFeature.ENCODING - jersey.config.server.mvc.encoding.freemarker`: Property used to configure a default
  encoding that will be used if none is specified in
  [@Produces](https://eclipse-ee4j.github.io/jaxrs-api/apidocs/2.1.6/javax/ws/rs/Produces.html) annotation. If property
  is not defined the UTF-8 encoding will be used as a default value.
  
Maven users can find this module at coordinates

```xml
<dependency>
    <groupId>org.glassfish.jersey.ext</groupId>
    <artifactId>jersey-mvc-freemarker</artifactId>
    <version>2.31</version>
</dependency>
```

and for non-Maven users the list of dependencies is available at
[jersey-mvc-freemarker](https://eclipse-ee4j.github.io/jersey.github.io/project-info/2.31/jersey/project/jersey-mvc-freemarker/dependencies.html). 

### JSP

> **Limitations of Jersey JSP MVC Templates**
>
> Jersey web applications that want to use JSP templating support should be registered as Servlet filters rather than
> Servlets in the application's `web.xml`. The `web.xml`-less deployment style introduced in Servlet 3.0 is not
> supported at the moment for web applications that require use of Jersey MVC templating support.

JSP template processor resolves absolute template references to processable template references represented as JSP pages
as follow

1. if the absolute template reference does not end in `.jsp` append this suffix to the reference; and
2. if `ServletContext.getResource` returns a non-`null` value for the reference then return the reference as the
   processable template reference otherwise return `null` (to indicate the absolute reference has not been resolved by
   the JSP template processor).
   
Thus the absolute template reference `/com/foo/Foo/index` would be resolved to `/com/foo/Foo/index.jsp`, provided there
exists a `/com/foo/Foo/index.jsp` JSP page in the web application. 

Jersey will assign the model instance to the attribute named `model` or `it`. So it is possible to reference the `foo`
property on the `Foo` resource from the JSP template as follows: 

```html
<h1>${model.foo}</h1>
```

or

```html
<h1>${it.foo}</h1>
```

To include another JSP page in the currently processed one a custom `include` tag can be used. Mandatory parameter
`page` represents a relative template name which would be absolutized using the same resolving resource class as the
parent JSP page template.

```html
<%@page contentType="text/html"%>
<%@page pageEncoding="UTF-8"%>
 
<%@taglib prefix="rbt" uri="urn:org:glassfish:jersey:servlet:mvc" %>
 
<html>
    <body>
 
    <rbt:include page="include.jsp"/>
 
    </body>
</html>
```

Available configuration property include
`JspMvcFeature.TEMPLATE_BASE_PATH - jersey.config.server.mvc.templateBasePath.jsp`, which controls the base path where
JSP templates are located.

Maven users can find this module at coordinates

```xml
<dependency>
    <groupId>org.glassfish.jersey.ext</groupId>
    <artifactId>jersey-mvc-jsp</artifactId>
    <version>2.31</version>
</dependency>
```

and for non-Maven users the list of dependencies is available at
[jersey-mvc-jsp](https://eclipse-ee4j.github.io/jersey.github.io/project-info/2.31/jersey/project/jersey-mvc-jsp/dependencies.html). 

## Writing Custom Templating Engines

To add support for other (custom) templating engines into Jersey MVC Templating facility, you need to implement the
***[TemplateProcessor](https://eclipse-ee4j.github.io/jersey.github.io/apidocs/snapshot/jersey/org/glassfish/jersey/server/mvc/spi/TemplateProcessor.html)***
and register this class into your application.

> ✏️ When writing template processors it is recommend that you use an appropriate unique suffix for the processable
> template references, in which case it is then possible to easily support mixing of multiple templating engines in a
> single application without conflicts.

```java
/**
 * Custom TemplateProcessor.
 */
@Provider
class MyTemplateProcessor implements TemplateProcessor<String> {
 
    @Override
    public String resolve(String path, final MediaType mediaType) {
        final String extension = ".testp";
 
        if (!path.endsWith(extension)) {
            path = path + extension;
        }
 
        final URL u = this.getClass().getResource(path);
        return u == null ? null : path;
    }
 
    @Override
    public void writeTo(
            String templateReference,
            Viewable viewable,
            MediaType mediaType,
            OutputStream out
    ) throws IOException {
        final PrintStream ps = new PrintStream(out);
        ps.print("path=");
        ps.print(templateReference);
        ps.println();
        ps.print("model=");
        ps.print(viewable.getModel().toString());
        ps.println();
    }
}
```

```java
// Registering custom TemplateProcessor
new ResourceConfig()
        .register(MyTemplateProcessor.class)
        .register( ... );
```

> 📋️  In a typical set-up, projects using the Jersey MVC templating support would depend on the base module that
> provides the API and SPI and a single templating engine module for the templating engine of your choice. These modules
> need to be mentioned explicitly in your `pom.xml` file.

If you want to use just templating API infrastructure provided by Jersey for the MVC templating support in order to
implement your custom support for a templating engine other than the ones provided by Jersey, you will need to add the
base
[jersey-mvc](https://eclipse-ee4j.github.io/jersey.github.io/project-info/2.31/jersey/project/jersey-mvc/dependencies.html)
module into the list of your dependencies:

```xml
<dependency>
    <groupId>org.glassfish.jersey.ext</groupId>
    <artifactId>jersey-mvc</artifactId>
    <version>2.31</version>
</dependency>
```

## Other Examples

To see an example of MVC (JSP) templating support in Jersey refer to the
[MVC (Bookstore) Example](https://github.com/eclipse-ee4j/jersey/tree/master/examples/bookstore-webapp).
