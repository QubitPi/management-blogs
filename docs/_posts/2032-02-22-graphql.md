---
layout: post
title: GraphQL Reference Guide (Updated Daily...)
tags: [GraphQL, Data]
color: rgb(224, 1, 152)
feature-img: "assets/img/post-cover/31-cover.png"
thumbnail: "assets/img/post-cover/31-cover.png"
date: 2032-02-22
author: QubitPi
excerpt_separator: <!--more-->
---

<!--more-->

* TOC
{:toc}

## Understanding GraphQL Query Syntax

Many years of software engineering experience told me that software documentation is never a good way to learn a new
technology unless it is written by some strong-marketing-minded engineer. I believe the best way to learn a new tech is
to dive into its source code and have its documentation as an aid that facilitates your understanding. In this post I am
going to show you how to master **GraphQL query language** by looking at its source file.

[**Note that you will need to have solid understanding of ANTLR4 before moving on**]({{ "/assets/pdf/the-definitive-antlr-4-reference.pdf" | relative_url}}).

GraphQL query language is defined using ANTLR. This means understanding its grammar is essentially the same thing as
unserstanding its ANTLR definition. We will understnd GraphQL query language by reading its ANTLR grammar. Leaarning it
this way will allow to transform GraphQL query to internal query format adapted in your own data system.

### ANTLR Basics

ANTLR is written in Java. Since we will be demonstrating ANTLR through command line, installing ANTLR itself is simply a
matter of downloading the latest jar and storing it somewhere appropriate. The jar contains all dependencies necessary
to run the ANTLR tool and the runtime library needed to compile and execute programs generated by ANTLR.

We will being using version 4.8 of ANTLR. The `jar` of it is available at
[https://www.antlr.org/download/antlr-4.8-complete.jar](https://www.antlr.org/download/antlr-4.8-complete.jar)

Here is simple grammer that recoginizes phrases like hello jack and hello world:

![antlr-hello.png not loaded property]({{ "/assets/img/antlr-hello.png" | relative_url}})

To keep things tidy, let's put this grammar file `Hello.g4` in its own directory, such as `hello`. We put `\hello` in
the same directory hosting the `antlr-4.8-complete.jar`

Then we can run ANTLR on it and compile the results:

![antlr-run-hello.png not loaded property]({{ "/assets/img/antlr-run-hello.png" | relative_url}})

Running the ANTLR tool on `Hello.g4` generates an executable recognizer embodied by `HelloParser.java` and
`HelloLexer.java`, but we don't have a main program to trigger language recognition. Fortunately, ANTLR provides a
flexible testing tool in the runtime library called `TestRig`. It can display lots of information about how a recognizer
matches input from a file or standard input. `TestRig` uses Java reflection to invoke compile recognizers.

The test rig takes a grammar name, a starting rule name kind of like a `main()` method, and various options that dicate
the output we want.

Let's say we'd like to print the tokens created during recognition. Tokens are vocabulary symbols like keyword `hello`
and identifier `jack`. To test the grammar, start up the test rig as follows:

![antlr-run.png not loaded property]({{ "/assets/img/antlr-run.png" | relative_url}})

Note that the ".:../antlr-4.8-complete.jar" is basically saying add the current directory (of all `.class`) and the path
to `antlr-4.8-complete.jar` to `CLASSPATH` so that compiler will be able to reference properly.

After you hit "enter", the computer will patiently wait for you to type in something like "hello jack" followed by a
newline. At that point, you must type the end-of-file character(ctrl-D) to terminate reading from standard input;
otherwise, the program will stare at your for eternity. Once the recognizer has read all of the input, `TestRig` prints
out the list of tokens per the use of option `-tokens`. You should be able see the output of the following:

```
[@0,0:4='hello',<'hello'>,1:0]
[@1,6:9='jack',<ID>,1:6]
[@2,11:10='<EOF>',<EOF>,2:0]
```

Each line of the output represents a single token and shows everything we know about the token. For example, the
`[@1,6:9='jack',<ID>,1:6]` indicates that the token

* is the second token (indexed from 0)
* goes from character position 6 to 9 (inclusive starting from 0)
* has text `jack`
* has token type of `ID`
* is on line 1 (from 1), and
* is at character position 6 (starting from zero and counting tabs as a single character)

We can print the parse tree in LISP-style text form just as easily:

![antlr-lisp.png not loaded property]({{ "/assets/img/antlr-lisp.png" | relative_url}})

The output shall be

```
(r hello jack)
```

The easiest way to see how a grammar recognizes the input, though, is by looking at the parse tree visually. Running
`TestRig` with the `-gui` option produces the following dialog box:

![antlr-parse-tree.png not loaded property]({{ "/assets/img/antlr-parse-tree.png" | relative_url}})

Running `TestRig` without any command-line options prints a small help message:

```bash
$ java -cp ".:../antlr-4.8-complete.jar" org.antlr.v4.gui.TestRig
java org.antlr.v4.gui.TestRig GrammarName startRuleName
  [-tokens] [-tree] [-gui] [-ps file.ps] [-encoding encodingname]
  [-trace] [-diagnostics] [-SLL]
  [input-filename(s)]
Use startRuleName='tokens' if GrammarName is a lexer grammar.
Omitting input-filename makes rig read from stdin.
```

We've already discussed `-tokens`, `-tree`, and `-gui`.

* `-ps file.ps` generates a visual representation of the parse tree in PostScript and stores it in `file.ps`.
* `-encoding encodingnam`e specifies the test rig input file encoding if the current locale would not read the input
  properly, such as the case of parsing a Japanese-encoded XML file
* `-trace` prints the rule name and current token upon rule entry and exit
* `-diagnostics` turns on diagnostic messages during parsing. This generates messages only for unusual situations such
  as ambiguous input phrases
* `-SLL` uses a faster but slightly weaker parsing strategy.

### GraphQL Query Syntax

The definition of GraphQL query language(6.0) is the following:

```g4
grammar Graphql;

@header {
    package graphql.parser.antlr;
}

// Document

document : definition+;

definition:
operationDefinition |
fragmentDefinition |
typeSystemDefinition
;

operationDefinition:
selectionSet |
operationType  name? variableDefinitions? directives? selectionSet;

operationType : SUBSCRIPTION | MUTATION | QUERY;

variableDefinitions : '(' variableDefinition+ ')';

variableDefinition : variable ':' type defaultValue?;

variable : '$' name;

defaultValue : '=' value;

// Operations

selectionSet :  '{' selection+ '}';

selection :
field |
fragmentSpread |
inlineFragment;

field : alias? name arguments? directives? selectionSet?;

alias : name ':';

arguments : '(' argument+ ')';

argument : name ':' valueWithVariable;

// Fragments

fragmentSpread : '...' fragmentName directives?;

inlineFragment : '...' typeCondition? directives? selectionSet;

fragmentDefinition : 'fragment' fragmentName typeCondition directives? selectionSet;

fragmentName :  name;

typeCondition : 'on' typeName;

// Value

name: NAME | FRAGMENT | QUERY | MUTATION | SUBSCRIPTION | SCHEMA | SCALAR | TYPE | INTERFACE | IMPLEMENTS | ENUM | UNION | INPUT | EXTEND | DIRECTIVE;

value :
IntValue |
FloatValue |
StringValue |
BooleanValue |
NullValue |
enumValue |
arrayValue |
objectValue;

valueWithVariable :
variable |
IntValue |
FloatValue |
StringValue |
BooleanValue |
NullValue |
enumValue |
arrayValueWithVariable |
objectValueWithVariable;


enumValue : name ;

// Array Value

arrayValue: '[' value* ']';

arrayValueWithVariable: '[' valueWithVariable* ']';


// Object Value

objectValue: '{' objectField* '}';
objectValueWithVariable: '{' objectFieldWithVariable* '}';
objectField : name ':' value;
objectFieldWithVariable : name ':' valueWithVariable;

// Directives

directives : directive+;

directive :'@' name arguments?;

// Types

type : typeName | listType | nonNullType;

typeName : name;
listType : '[' type ']';
nonNullType: typeName '!' | listType '!';


// Type System
typeSystemDefinition:
schemaDefinition |
typeDefinition |
typeExtensionDefinition |
directiveDefinition
;

schemaDefinition : SCHEMA directives? '{' operationTypeDefinition+ '}';

operationTypeDefinition : operationType ':' typeName;

typeDefinition:
scalarTypeDefinition |
objectTypeDefinition |
interfaceTypeDefinition |
unionTypeDefinition |
enumTypeDefinition |
inputObjectTypeDefinition
;

scalarTypeDefinition : SCALAR name directives?;

objectTypeDefinition : TYPE name implementsInterfaces? directives? '{' fieldDefinition+ '}';

implementsInterfaces : IMPLEMENTS typeName+;

fieldDefinition : name argumentsDefinition? ':' type directives?;

argumentsDefinition : '(' inputValueDefinition+ ')';

inputValueDefinition : name ':' type defaultValue? directives?;

interfaceTypeDefinition : INTERFACE name directives? '{' fieldDefinition+ '}';

unionTypeDefinition : UNION name directives? '=' unionMembers;

unionMembers:
typeName |
unionMembers '|' typeName
;

enumTypeDefinition : ENUM name directives? '{' enumValueDefinition+ '}';

enumValueDefinition : enumValue directives?;

inputObjectTypeDefinition : INPUT name directives? '{' inputValueDefinition+ '}';

typeExtensionDefinition : EXTEND objectTypeDefinition;

directiveDefinition : DIRECTIVE '@' name argumentsDefinition? 'on' directiveLocations;

directiveLocation : name;

directiveLocations :
directiveLocation |
directiveLocations '|' directiveLocation
;


// Token

BooleanValue: 'true' | 'false';

NullValue: 'null';

FRAGMENT: 'fragment';
QUERY: 'query';
MUTATION: 'mutation';
SUBSCRIPTION: 'subscription';
SCHEMA: 'schema';
SCALAR: 'scalar';
TYPE: 'type';
INTERFACE: 'interface';
IMPLEMENTS: 'implements';
ENUM: 'enum';
UNION: 'union';
INPUT: 'input';
EXTEND: 'extend';
DIRECTIVE: 'directive';
NAME: [_A-Za-z][_0-9A-Za-z]*;


IntValue : Sign? IntegerPart;

FloatValue : Sign? IntegerPart ('.' Digit*)? ExponentPart?;

Sign : '-';

IntegerPart : '0' | NonZeroDigit | NonZeroDigit Digit+;

NonZeroDigit: '1'.. '9';

ExponentPart : ('e'|'E') Sign? Digit+;

Digit : '0'..'9';


StringValue: '"' (~(["\\\n\r\u2028\u2029])|EscapedChar)* '"';

Comment: '#' ~[\n\r\u2028\u2029]* -> channel(2);

Ignored: (UnicodeBOM|Whitespace|LineTerminator|Comma) -> skip;

fragment EscapedChar :   '\\' (["\\/bfnrt] | Unicode) ;
fragment Unicode : 'u' Hex Hex Hex Hex ;
fragment Hex : [0-9a-fA-F] ;

fragment LineTerminator: [\n\r\u2028\u2029];

fragment Whitespace : [\u0009\u0020];
fragment Comma : ',';
fragment UnicodeBOM : [\ufeff];
```

A GraphQL query is internally called a "**document**". The definition of a GraphQL query/document is the following

> A **query/document** is
> 
> * an [operation](#operation), or
> * a fragment, or
> * a type system

From this point, we will simply refer a GraphQL query as "document". This is a recursive definition, which is usual in
an ANTLR4 definition language. Next we will look at what an "operation" is.

#### Operation

> An **operation** is either
>
> * a set of [selection](#selection), or
> * a set of [selection with operation](#selection-with-operation)

##### Selection

A set of selections(a selection set) is enclosed in a pair of curly braces. The definition of a selection is the
following:

> A **selection** is one of
>
> * a field, or
> * a fragment spread, or
> * a inline fragment

###### Field

> * A field, as defined below, is a name with optional alias, arguments, directives, or selection set.
> * A name is a set of pre-defined string constants or arbitrary string (`NAME`) show below.

![graphql-field-def.png not loaded property]({{ "/assets/img/graphql-field-def.png" | relative_url}})

The simplest field becomes a query itself. This is a correct syntax, but GraphQL Java at runtime
[requires a sub-selection](https://github.com/graphql-java/graphql-java/blob/610a5276ee9588a147de1a7b0dc525bcbd189221/src/main/java/graphql/validation/rules/ScalarLeafs.java#L29-L30)
in order to get some meaningful data back:

![graphql-sub-selection.png not loaded property]({{ "/assets/img/graphql-sub-selection.png" | relative_url}})

You can see immediately that the query has exactly the same shape as the result. This is essential to GraphQL, because
you always get back what you expect, and the server knows exactly what fields the client is asking for.

Notice in the definition, a field can also be a name followed by a sub-set of selections. This is somehow enforced at
runtime as demonstrated above. The sub-selection can also refer to Objects. In that case, you can make a sub-selection
of fields for that object. **GraphQL queries can traverse related objects and their fields, letting client fetch lots of
related data in one request**, instead of making several roundtrips, for example:

![graphql-single-round-trip.png not loaded property]({{ "/assets/img/graphql-single-round-trip.png" | relative_url}})

####### Argument

[The definition of field](#field) also recursively defines argument:

![graphql-argument.png not loaded property]({{ "/assets/img/graphql-argument.png" | relative_url}})

* A field can have one or multiple arguments surrounded by a pair of parenthesis
* An argument is a column-separated name-value pair, in which value is defined by multiple valid value types, such as
  `int` and `enum`
  
Arguments gives you the ability to pass arguments to fields:

![graphql-argument-example.png not loaded property]({{ "/assets/img/graphql-argument-example.png" | relative_url}})

We can even pass arguments into scalar fields when data transformations is implemented on server

![graphql-argument-scalar.png not loaded property]({{ "/assets/img/graphql-argument-scalar.png" | relative_url}})

Arguments can be of many different types. The example above used Enumeration type, which represents one of a finite set
of options. GraphQL comes with a default set of types, but a GraphQL server can also declare its own custom types, as
long as they can be serialized into your transport format.

####### Aliases

When [Field](#field) includes alias, you can query the same field with different argument.

An alias has a name followed by a column. The part after the column is the name that is to be aliased:
`alias : name ':';`

![graphql-alias-example.png not loaded property]({{ "/assets/img/graphql-alias-example.png" | relative_url}})

In the example above, the two fields `hero` would have conflicted, but not because they are aliased.

####### Directive

A field selection can have a set of directives:

![graphql-directive.png not loaded property]({{ "/assets/img/graphql-directive.png" | relative_url}})

* Directives is composed of one or more directive clauses
* A directive starts with `@` sign followed by a string which represents the name of the directive. A directive can
  optionally have [Argument](#argument)
  
Understanding **directive** requires knowledge of [variables](#variables). We will talk more about it when we look at
[variables](#variables) definitions.

####### Fragments

![graphql-fragments.png not loaded property]({{ "/assets/img/graphql-fragments.png" | relative_url}})

* A standard fragment starts with "..." followed by a fragment name
* Fragment works with [Directive](#directive)

Let's say we had a relatively complicated page, which lets us look at two heros side by side, along with their friends.
This query requires client to repeat the fields - one for each side of comparison.

With GraphQL _fragment_, client can construct sets of fields and then inlude them in queries. For example

![graphql-fragment-excample.png not loaded property]({{ "/assets/img/graphql-fragment-excample.png" | relative_url}})

####### Inline Fragments

![graphql-inline-fragment.png not loaded property]({{ "/assets/img/graphql-inline-fragment.png" | relative_url}})

* An inline fragment starts with "..."
* An inline fragment must have a set of [selections](#selection)
* An inline fragment can optionally have type condition and directives
* A type condition starts with "`on`" followd by type name

##### Selection with Operation

* A selection with operation starts with an _operation type_, which is one of "subscription/mutation/query" followed by
  an optional name associated with this selection. It ends with a [sub-selection](#selection).
* Named selection can have variables passed by client. The variables are surounded by a pair of parenthesis. Each
  varialbe has the form of `$name: <type>`. The variable can have a default value, in which case the variable has the
  form of `$name: <type> = value`
* Selection with operations supports [directive](#directive)
            
![grpahql-selection-with-operation.png not loaded property]({{ "/assets/img/grpahql-selection-with-operation.png" | relative_url}})

Here is an example that includes the keyword `query` as operation type and `HeroNameAndFriends` as operation name:

![graphql-selection-with-operation-example.png not loaded property]({{ "/assets/img/graphql-selection-with-operation-example.png" | relative_url}})

The operation is required in multi-operation query and is useful for debugging, because you can find log by name.

###### Variables

Variables allows dynamic argument passing. For example, client dynamically selects an option from drop-down box and set
that option as the value to a field argument

GraphQL does this by passing those variables as a separate dictionary (not in GraphQL query). For example

![graphql-variable-example.png not loaded property]({{ "/assets/img/graphql-variable-example.png" | relative_url}})

####### Directives

Directive is essentially an application of variable and is able to dynamically change the structure of queries using
variables. For example

![graphql-directive-example.png not loaded property]({{ "/assets/img/graphql-directive-example.png" | relative_url}})

The core GraphQL specification includes 2 directives, which must be supported by any spec-compliant GraphQL server
implementation:

1. `@include(if: Boolean)` Include this field in the result if the argument evaluates to `true`
2. `@skip(if: Boolean)` Skip this field if the arguments evaluates to `true`

####### Mutation

One [operation](#selection-with-operation) type is mutation. The purpose of it is we cannot mutate data with a `GET`
request, similary we need a convension that distinguish a **write GraphQL query** to a **read GraphQL query**.

_After the mutation, the mutated data is queriable in the same write request_ such as the following:

![graphql-mutation-example.png not loaded property]({{ "/assets/img/graphql-mutation-example.png" | relative_url}})

In the example above, you persist an object of type `Review`. This object is included in variable. The query itself
includes all the fields that are returnd in this mutation list, i.e. stars.

Note that mutation can persists multiple objects of multipe types.

#### Type System

A *type system* defines a schema, a type, a type extension, and direcive

![graphql-type.png not loaded property]({{ "/assets/img/graphql-type.png" | relative_url}})

Let's starts with type definition

##### Type

![graphql-type-definition.png not loaded property]({{ "/assets/img/graphql-type-definition.png" | relative_url}})

* A [scalar type](#scalar-type) is defined in the form of "scalar typeName <directives>"
* An [object type](#object-type) is defined in the form of

```
type typeName <implement interface1 interface2 ...> <directives> {
    fieldName<(arguments)> : fieldType <directiuves>
    ...
}
```

####### Scalar Type

A GraphQL [object type](#object-type) has a name and fields, but at some point those fields have to resolve to some
concrete data. That's where the scalar types come in: they represents the leaves of the query.

In the following query, the `name` and `appearsIn` fields resolve to scalar types:

![graphql-scalar-type-example.png not loaded property]({{ "/assets/img/graphql-scalar-type-example.png" | relative_url}})

GraphQL comes with a set of default scalar types:

* `Int` A signed 32-bit integer
* `Float` A signed double-precision floating-point value
* `String` An UTF-8 character sequence
* `Boolean`
* `ID` ID is serialized in the same way as a String does

To specify custom scalar types, Date for example

```
scalar Date
```

Then it's up to implementation how that type is to be serialized, deserialized, and validated.

####### Object Type

Object represent things you can fetch from GraphQL service. For example

![graphql-object-type-example.png not loaded property]({{ "/assets/img/graphql-object-type-example.png" | relative_url}})

##### Schema

![graphql-schema.png not loaded property]({{ "/assets/img/graphql-schema.png" | relative_url}})

* A schema defintion has the form of

        schema <optional directive> {
            # one or more operation type definition
        }

* A schema defines one mor more operation type
* An operation type definition has the form of "subscription/mutation/query : typeName". For example

        schema {
            query: Query
            mutation: Mutation
        }
        
### What's Missing from Grammar

#### Sorting

If you look at the beginning of [GraphQL Query Syntax](#graphql-query-syntax), there is no definition for sorting and
pagination. This is because GraphQL is not a query language. We will need to specify sorting grammar by ourselves. What
this means is we have the absolute freedom to specify sorting and pagination syntax.

For example, we can sort in either ascending or descending order by prepending the attribute expression with a "+" or
"-" character. If no order character is provided, sort order can defaults to ascending, for example

![graphql-sorting-example.png not loaded property]({{ "/assets/img/graphql-sorting-example.png" | relative_url}})

#### Pagination

[GraphQL recommends some pagination syntax](https://graphql.org/learn/pagination/)
