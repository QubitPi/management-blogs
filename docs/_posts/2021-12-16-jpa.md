---
layout: post
title: Understanding Java Persistence API (JPA)
tags: [Java, Database, Specification]
color: rgb(1, 91, 156)
feature-img: "assets/img/post-cover/12-cover.png"
thumbnail: "assets/img/post-cover/12-cover.png"
author: QubitPi
excerpt_separator: <!--more-->
---

<!--more-->

## Must-Reads 

* [JPA Specification]({{ "/assets/pdf/JPA Specification.pdf" | relative_url}})



### Understanding Transaction in Spring

Spring supports RDMBS transations by 2 approaches:

1. **Programmatic Transactions** Transaction management code needs to be explicitly written so as to commit when
   everything is successful and rolling back if anything goes wrong. The transaction management code is tightly bound to
   the business logic in this case.
2. **Declarative Transactions** Transaction management is separate from business logic. Spring supports declarative
   transactions using transaction advice (using AOP) via XML configuration in the spring context or with
   [`@Transactional` annotation](#transactional-annotation)
   
#### @Transactional annotation

At a high level, when a class declares `@Transactional` on itself or its members, Spring creates a proxy that implements
the same interface(s) as the class you're annotating. In other words, Spring wraps the bean in the proxy and the bean
itself has no knowledge of it. A proxy provides a way for Spring to inject behaviors before, after, or around method
calls into the object being proxied.

The generated proxy object is supplied with a "**TransactionInterceptor**", which is created by Spring. So when the
`@Transactional` method is called from client code, the `TransactionInterceptor` gets invoked first from the proxy
object, which begins the transaction and eventually invokes the method on the target bean. When the invocation finishes,
the TransactionInterceptor **commits/rolls back** the transaction accordingly.

> âš ï¸ Note that **only calls from "outside" the target bean go through the proxy**.

##### Understanding "readOnly" And "propagate" Attributes


###### "readOnly"

If you don't explicitly set `eadOnly` attribute to `true`, you will have read/write transactions.

> ðŸ“‹ It is always better to explicitly specify the `readOnly` attribute, as we have noticed some massive performance
> improvements with Hibernate because of this.

###### "propagate"

Spring allows you to control the behavior of logical and physical transactions via transaction propagation mechanisms.
There are **seven** types of transaction propagation mechanisms that you can set in a Spring application via
`org.springframework.transaction.annotation.Propagation`

By default, the only exceptions that cause a transaction to roll back are the unchecked exceptions (like
`RuntimeException`). Nevertheless, you can control this aspect via the `noRollbackFor`, `noRollbackForClassName`,
`rollbackFor`, and `rollbackForClassName` elements of `@Transactional`.

1. **Propagation.REQUIRED** The default setting of a `@Transactional` annotation. The `REQUIRED` propagation can be
   interpreted as follows:
   
     - If there is no existing physical transaction, then the Spring container will create one.
     - If there is an existing physical transaction, then the methods annotated with `REQUIRE` will participate in this
       physical transaction.
     - Each method annotated with REQUIRED demarcates a logical transaction and these logical transactions participate
       in the same physical transaction.
     - Each logical transaction has its own scope, but, in case of this propagation mechanism, all these scopes are
       mapped to the same physical transaction.

   Because all the scopes of the logical transactions are mapped to the same physical transaction, when one of these logical transactions is rolled back, all the logical transactions of the current physical transaction are rolled back.
2. **Propagation.REQUIRES_NEW** instructs the Spring container to always create a new physical transaction. Such
   transactions can also declare their own timeouts, read-only, and isolation level settings and not inherit an outer
   physical transaction's characteristics.

   Pay attention to how you handle this aspect since each physical transaction needs its own database connection. So, an
   outer physical transaction will have its own database connection, while `REQUIRES_NEW` will create the inner physical
   transaction and will bound a new database connection to it. In a synchronous execution, while the inner physical
   transaction is running, the outer physical transaction is suspended and its database connection remains open. After
   the inner physical transaction commits, the outer physical transaction is resumed, continuing to run and
   commit/rollback.

   If the inner physical transaction is rolled back, it may or may not affect the outer physical transaction.
3. **Propagation.NESTED** acts like `REQUIRED`, only it uses savepoints between nested invocations. In other words,
   inner logical transactions may roll back independently of outer logical transactions.

   > âš ï¸ Trying to use `NESTED` with Hibernate JPA will result in a Spring exception as follows:
   > 
   > ```
   > NestedTransactionNotSupportedException: JpaDialect does not support savepoints
   > - check your JPA provider capabilities
   > ```
   > 
   > This is happening because Hibernate JPA doesnâ€™t support nested transactions.
4. **Propagation.MANDATORY** requires an existing physical transaction or will cause an exception
5. **Propagation.NEVER** states that no physical transaction should exist. If a physical transaction is found, then
   `NEVER` will cause an exception. The code inside `NEVER`, though, can open physical transactions with no problem.
6. **Propagation.NOT_SUPPORTED** states that if a physical transaction exists, then it will be suspended before
   continuing. This physical transaction will be automatically resumed at the end. After this transaction is resumed,
   it can be rolled back (in case of a failure) or committed. If a contained transactions thows `RuntimeException`, the
   exception will propagate to this transaction and this logical transaction is rolled back
7. **Propagation.SUPPORTS** states that if a physical transaction exists, then it will execute the demarcated method as
   a logical transaction in the context of this physical transaction(i.e. rolling back comes together). Otherwise, it
   will execute this method outside of a physical transaction
