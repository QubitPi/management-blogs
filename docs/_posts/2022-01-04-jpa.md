---
layout: post
title: (WIP) Understanding Java Persistence API (JPA)
tags: [Java, Database, Specification, JPA]
color: rgb(0, 196, 0)
feature-img: "assets/img/post-cover/23-cover.png"
thumbnail: "assets/img/post-cover/23-cover.png"
author: QubitPi
excerpt_separator: <!--more-->
---

I'd like to start 2022 posts with my favorite technology - JPA (งツ)ว

<!--more-->

* TOC
{:toc}
  
# JPA Specification

## Entities

### The Entity Class

* The entity class must be annotated with the **`Entity`** annotation.
* The entity class must have a **no-arg constructor**. The entity class may have other constructors as well.
* The no-arg constructor must be **public** or **protected**.
* The entity class must be a **top-level class**
* An enum or interface must not be designated as an entity.
* The entity class **must not be final**. No methods or persistent instance variables of the entity class may be final.
* If an entity instance is to be passed by value as a detached object (e.g., through a remote interface), the entity
  class must implement the Serializable interface.
  
* Entities support inheritance, polymorphic associations, and polymorphic queries.
* Both abstract and concrete classes can be entities. Entities may extend non-entity classes as well as entity classes,
  and non-entity classes may extend entity classes.
* **The persistent state of an entity is represented by instance variables**, which may correspond to JavaBeans
  properties. An instance variable must be directly accessed _only_ from within the methods of the entity by the entity
  instance itself. **Instance variables must not be accessed by clients of the entity**. The state of the entity is
  available to clients only through the entity's methods, i.e. accessor methods (getter/setter methods) or other
  business methods.

### Persistent Fields and Properties

> ![http://xyq.163.com/images/emote/32.gif]({{ "/assets/img/32.gif" | relative_url}}) The persistent fields and
> properties of an entity class are generically referred to as the "**attributes**" of the class

The persistent state of an entity is accessed by the persistence provider runtime either via JavaBeans style property
accessors ("**property access**") or via instance variables ("**field access**"). Whether persistent properties or
persistent fields or a combination of the two is used for the provider’s access to a given class or entity hierarchy is
determined by "[Access Type](#access-type)". 

The instance variables of a class must be private, protected, or package visibility independent of whether field access
or property access is used. When property access is used, the property accessor methods must be public or protected

It is required that the entity class follow the method signature conventions for JavaBeans read/write properties (as
defined by the JavaBeans Introspector class) for persistent properties when property access is used.

In this case, for every persistent property `property` of type `T` of the entity, there is a getter method,
`getProperty`, and setter method `setProperty`. For boolean properties, `isProperty` may be used as an alternative
name for the getter method.

> ![http://xyq.163.com/images/emote/32.gif]({{ "/assets/img/32.gif" | relative_url}}) Specifically, if `getX` is the
> name of the getter method and `setX` is the name of the setter method, where X is a string, the name of the
> persistent property is defined by the result of `java.beans.Introspector.decapitalize(X)`.

For single-valued persistent properties, these method signatures are:

* `T getProperty()`
* `void setProperty(T t)`

Collection-valued persistent fields and properties must be defined in terms of one of the following collection-valued
interfaces:

* `java.util.Collection`
* `java.util.Set`
* `java.util.List`
* `java.util.Map`

> ![http://xyq.163.com/images/emote/32.gif]({{ "/assets/img/32.gif" | relative_url}}) Portable applications should not
> expect the order of a list to be maintained across persistence contexts unless the `OrderColumn` construct is used or
> unless the `OrderBy` construct is used and the modifications to the list observe the specified ordering.

The collection implementation type may be used by the application to initialize fields or properties before the entity
is made persistent. **Once the entity becomes managed (or detached), subsequent access must be through the interface
type**.

> ![http://xyq.163.com/images/emote/32.gif]({{ "/assets/img/32.gif" | relative_url}}) The terms "collection" and
> "collection-valued" are used in this specification to denote any of the above types unless further qualified. In cases 
> where a `java.util.Collection` type (or one of its subtypes) is to be distinguished, the type is identified as such. 
> The terms "map" and "map collection" are used to apply to a collection of type `java.util.Map` when a collection of
> type `java.util.Map` needs to be distinguished as such.

In addition to returning and setting the persistent state of the instance, property accessor methods may contain other 
business logic as well, for example, to perform validation. The persistence provider run- time executes this logic when 
property-based access is used.

> ![http://xyq.163.com/images/emote/45.gif]({{ "/assets/img/45.gif" | relative_url}}) Caution should be exercised in 
> adding business logic to the accessor methods when property access is used. The order in which the persistence
> provider runtime calls these methods when loading or storing persistent state is not defined. Logic contained in such 
> methods therefore should not rely upon a specific invocation order.

If a persistence context is joined to a transaction, runtime exceptions thrown by property accessor methods cause the 
current transaction to be marked for rollback; exceptions thrown by such methods when used by the persistence runtime to 
load or store persistent state cause the persistence runtime to mark the current transaction for rollback and to throw a 
`PersistenceException` that wraps the application exception.

Entity subclasses may override the property accessor methods. However, portable applications must not override the 
object/relational mapping metadata that applies to the persistent fields or properties of entity superclasses.

The persistent fields or properties of an entity may be of the following types:

* Java primitive types
* `java.lang.String`
* other Java serializable types, including wrappers of the primitive types:
  - `java.math.BigInteger`
  - `java.math.BigDecimal`
  - `java.util.Date`
  - `java.util.Calendar`
  - `java.sql.Date`
  - `java.sql.Time`
  - `java.sql.Timestamp`
  - `byte[]`
  - `Byte[]`
  - `char[]`
  - `Character[]`
  - and user-defined types that implement the Serializable interface
* enums
* entity types
* collections of entity types
* [embeddable classes](#embeddable-classes)
* [collections of basic and embeddable types](#collections-of-embeddable-classes-and-basic-types)

#### Example

```java
@Entity
public class Customer implements Serializable {

    private Long id;
    private String name;
    private Address address;
    private Collection<Order> orders;
    private Set<PhoneNumber> phones;

    // No-arg constructor
    public Customer() { }

    // property access is used
    @Id
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    @OneToMany
    public Collection<Order> getOrders() {
        return orders;
    }

    public void setOrders(Collection<Order> orders) {
        this.orders = orders;
    }

    @ManyToMany
    public Set<PhoneNumber> getPhones() {
        return phones;
    }

    public void setPhones(Set<PhoneNumber> phones) {
        this.phones = phones;
    }

    // Business method to add a phone number to the customer
    public void addPhone(PhoneNumber phone) {
        this.getPhones().add(phone);
        phone.addCustomer(this); // Update the phone entity instance to refer to this customer
    }
}
```

### Access Type

### Embeddable Classes

### Collections of Embeddable Classes and Basic Types

(**To be continued...**)

## Isolation Level

### Serializability

In applications like Web services, banking, or airline reservations, hundreds of operations per second may be performed
on the database. The operations initiate at any of thousands or millions of sites, such as desktop computers or
automatic teller machines. It is entirely possible that we could have two operations affecting the same bank account or
flight, and for those operations to overlap in time. If so, they might interact in strange ways.

The problem is solved in SQL by the notion of a "**transaction**", which is informally _a group of operations that need
to be performed together_. SQL allows the programmer to state that a certain transaction must be serializable with
respect to other transactions. That is, these transactions must behave as if they were run serially - one at a time,
with no overlap

### Atomicity

In addition to nonserialized behavior that can occur if two or more database operations are performed about the same
time, it is possible for a single operation to put the database in an unacceptable state if there is a hardware or
software "crash" while the operation is executing.

Certain combinations of database operations need to be done **atomically**, that is, either they are both done or none
is done.

### Transactions

The solution to the problems of serialization and atomicity is to group database operations into transactions.

A **transaction** is a collection of one or more operations on the database that must be executed atomically; that is,
either all operations are performed or none are. In addition, SQL requires that, as a default, transactions are executed
in a serializable manner.

When using the generic SQL interface, each statement is a transaction by itself. SQL, however, allows the programmer to
group several statements into a single transaction. The SQL command `START TRANSACTION` is used to mark the beginning
of a transaction. There are two ways to end a transaction:

1. The SQL statement `COMMIT` causes the transaction to end successfully. Whatever changes to the database caused by the
   SQL statement or statements since the current transaction began are installed permanently
   in the database. _Before the `COMMIT` statement is executed, changes are tentative and may or may not be visible to
   other transactions_.
2. The SQL statement `ROLLBACK` causes the transaction to abort, or terminate unsuccessfully. Any changes made in
   response to the SQL statements of the transaction are undone, so they never permanently appear in the database.
   
> ![http://xyq.163.com/images/emote/105.gif]({{ "/assets/img/105.gif" | relative_url}}) Different systems may do different
> things to implement transactions. It is possible that as a transaction executes, it makes changes to the database. If
> the transaction aborts, then (unless the programmer took precautions) it is possible that these changes were seen by
> some other transaction. The most common solution is for the database system to lock the changed items until COMMIT or
> ROLLBACK is chosen, thus preventing other transactions from seeing the tentative change. Locks or an equivalent would
> surely be used if the user wants the transactions to run in a serializable fashion.
> 
> However, SQL offers several options regarding the treatment of tentative database changes. It is possible that the
> changed data is not locked and becomes visible even though a subsequent rollback makes the change disappear. It is up
> to the author of a transaction to decide whether it is safe for that transaction to see tentative changes of other
> transactions.

### Read-Only Transactions

If we tell the SQL execution system that our current transaction is readonly, that is, it will never change the
database, then it is quite possible that the SQL system will be able to take advantage of that knowledge. Generally it
will be possible for many read-only transactions accessing the same data to run in parallel, while they would not be
allowed to run in parallel with a transaction that wrote the same data.

We tell the SQL system that the next transaction is read-only by:

```sql
SET TRANSACTION READ ONLY;
```

This statement must be executed before the transaction begins. We can also inform SQL that the coming transaction may
write data by the statement

```sql
SET TRANSACTION READ WRITE;
```

However, this option is the default.

### Dirty Reads

**Dirty data** is a common term for data written by a transaction that has not yet committed. A **dirty read** is a read
of dirty data written by another transaction. The risk in reading dirty data is that the transaction that wrote it may 
ventually abort. If so, then the dirty data will be removed from the database, and the world is supposed to behave as if
that data never existed. If some other transaction has read the dirty data, then that transaction might commit or take
some other action that reflects its knowledge of the dirty data.

Sometimes the dirty read matters, and sometimes it doesn't. Other times it matters little enough that it makes sense to
risk an occasional dirty read and thus avoid:

1. The time-consuming work by the DBMS that is needed to prevent dirty reads, and
2. The loss of parallelism that results from waiting until there is no possibility of a dirty read.

SQL allows us to specify that dirty reads are acceptable for a given transaction:

```sql
1) SET TRANSACTION READ WRITE
2) ISOLATION LEVEL READ UNCOMMITTED;
```

The statement above does two things:

1. Line (1) declares that the transaction may write data.
2. Line (2) declares th at the transaction may run with the "isolation level" read-uncommitted. That is, the transaction
   is allowed to read dirty data.

Note that if the transaction is not read-only (i.e., it may modify the database), and we specify isolation level
`READ UNCOMMITTED`, then we must also specify `READ WRITE`, because read-write transactions with dirty reads entail
significant risks. If we want a read-write transaction to run with read-uncommitted as the isolation level, then we need
to specify `READ WRITE` explicitly.

> ![http://xyq.163.com/images/emote/32.gif]({{ "/assets/img/32.gif" | relative_url}}) So far, we have discussed 2
> isolation levels: [serializable](#serializability) and [read-uncommitted](#dirty-reads)

SQL provides a total of four isolation levels (2 of which have already been discussed above):

1. [serializable](#serializability)
2. [read-uncommitted](#dirty-reads)
3. [read-committed](#read-committed)
4. [repeatable-read](#repeatable-read)

The latter two can be specified for a given transaction by

```sql
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

or

```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

respectively. For each, the default is th at transactions are read-write. Incidentally, we also have the option of
specifying

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

However, this is the SQL default and need not be stated explicitly.

### Read-Committed

The **read-committed** isolation level, as its name implies, forbids the reading of dirty (uncommitted) data. However,
it does allow a transaction running at this isolation level to issue the same query several times and get different
answers, as long as the answers reflect data that has been written by transactions that already committed.

### Repeatable-Read

Now, let us consider isolation level repeatable-read. The term is something  of a misnomer, since the same query issued
more than once is not quite guaranteed  to get the same answer. Under **repeatable-read** isolation, if a tuple is
retrieved the first time, then we can be sure that the identical tuple will be retrieved again if the query is repeated.
However, it is also possible that a second or subsequent execution of the same query will retrieve phantom tuples. The
latter are tuples that result from _insertions_ into the database while our transaction is executing.

For example, consider a flight seat reservation problem. If we reserve seats under isolation level repeatable-read,
then a seat that is available on the first query will remain available at subsequent queries. However, suppose some new
tuples enter. For example, the airline may have switched the flight to a larger plane, creating some new tuples that
weren't there before. Then under repeatable-read isolation, a subsequent query for available seats may also retrieve the
new seats.

The table below summarizes the differences between the four SQL isolation levels:

![Error loading sql-4-isolations.png]({{ "/assets/img/sql-4-isolations.png" | relative_url}})

> ![http://xyq.163.com/images/emote/32.gif]({{ "/assets/img/32.gif" | relative_url}}) **Interactions Among Transactions
> Running at Different Isolation Levels**
> 
> A subtle point is that the isolation level of a transaction affects only what  data that transaction may see; it does
> not affect what any other transaction sees. As a case in point, if a transaction T is running at level serializable, 
> then the execution of T must appear as if all other transactions run either entirely before or entirely after T.
> However, if some of those transactions are running at another isolation level, then they may see the data written by T
> as T writes it. They may even see dirty data from T if they are running at isolation level read-uncommitted, and T
> aborts.

## Must-Reads

* [Database Systems - The Complete Book]({{ "/assets/pdf/Database Systems - the Complete Book.pdf" | relative_url}})
* [JPA Specification]({{ "/assets/pdf/JPA Specification.pdf" | relative_url}})
* [JTA Specification]({{ "/assets/pdf/JTA Specification.pdf" | relative_url}})
