---
layout: post
title: Understanding Java Persistence API (JPA)
tags: [Java, Database, Specification]
color: rgb(0, 196, 0)
feature-img: "assets/img/post-cover/16-cover.png"
thumbnail: "assets/img/post-cover/16-cover.png"
author: QubitPi
excerpt_separator: <!--more-->
---

<!--more-->

## Must-Reads 

* [Database Systems - The Complete Book]({{ "/assets/pdf/Database Systems - the Complete Book.pdf" | relative_url}})
* [JPA Specification]({{ "/assets/pdf/JPA Specification.pdf" | relative_url}})
* [JTA Specification]({{ "/assets/pdf/JTA Specification.pdf" | relative_url}})

## Isolation Level

### Serializability

In applications like Web services, banking, or airline reservations, hundreds of operations per second may be performed
on the database. The operations initiate at any of thousands or millions of sites, such as desktop computers or
automatic teller machines. It is entirely possible that we could have two operations affecting the same bank account or
flight, and for those operations to overlap in time. If so, they might interact in strange ways.

The problem is solved in SQL by the notion of a "**transaction**", which is informally _a group of operations that need
to be performed together_. SQL allows the programmer to state that a certain transaction must be serializable with
respect to other transactions. That is, these transactions must behave as if they were run serially - one at a time,
with no overlap

### Atomicity

In addition to nonserialized behavior that can occur if two or more database operations are performed about the same
time, it is possible for a single operation to put the database in an unacceptable state if there is a hardware or
software "crash" while the operation is executing.

Certain combinations of database operations need to be done **atomically**, that is, either they are both done or none
is done.


### Transactions

The solution to the problems of serialization and atomicity is to group database operations into transactions.

A **transaction** is a collection of one or more operations on the database that must be executed atomically; that is,
either all operations are performed or none are. In addition, SQL requires that, as a default, transactions are executed
in a serializable manner.

When using the generic SQL interface, each statement is a transaction by itself. SQL, however, allows the programmer to
group several statements into a single transaction. The SQL command `START TRANSACTION` is used to mark the beginning
of a transaction. There are two ways to end a transaction:

1. The SQL statement `COMMIT` causes the transaction to end successfully. Whatever changes to the database caused by the
   SQL statement or statements since the current transaction began are installed permanently
   in the database. _Before the `COMMIT` statement is executed, changes are tentative and may or may not be visible to
   other transactions_.
2. The SQL statement `ROLLBACK` causes the transaction to abort, or terminate unsuccessfully. Any changes made in
   response to the SQL statements of the transaction are undone, so they never permanently appear in the database.
   
> ![http://xyq.163.com/images/emote/105.gif]({{ "/assets/img/105.gif" | relative_url}}) Different systems may do different
> things to implement transactions. It is possible that as a transaction executes, it makes changes to the database. If
> the transaction aborts, then (unless the programmer took precautions) it is possible that these changes were seen by
> some other transaction. The most common solution is for the database system to lock the changed items until COMMIT or
> ROLLBACK is chosen, thus preventing other transactions from seeing the tentative change. Locks or an equivalent would
> surely be used if the user wants the transactions to run in a serializable fashion.
> 
> However, SQL offers several options regarding the treatment of tentative database changes. It is possible that the
> changed data is not locked and becomes visible even though a subsequent rollback makes the change disappear. It is up
> to the author of a transaction to decide whether it is safe for that transaction to see tentative changes of other
> transactions.

### Read-Only Transactions

If we tell the SQL execution system that our current transaction is readonly, that is, it will never change the
database, then it is quite possible that the SQL system will be able to take advantage of that knowledge. Generally it
will be possible for many read-only transactions accessing the same data to run in parallel, while they would not be
allowed to run in parallel with a transaction that wrote the same data.

We tell the SQL system that the next transaction is read-only by:

```sql
SET TRANSACTION READ ONLY;
```

This statement must be executed before the transaction begins. We can also inform SQL that the coming transaction may
write data by the statement

```sql
SET TRANSACTION READ WRITE;
```

However, this option is the default.

### Dirty Reads

**Dirty data** is a common term for data written by a transaction that has not yet committed. A **dirty read** is a read
of dirty data written by another transaction. The risk in reading dirty data is that the transaction that wrote it may 
ventually abort. If so, then the dirty data will be removed from the database, and the world is supposed to behave as if
that data never existed. If some other transaction has read the dirty data, then that transaction might commit or take
some other action that reflects its knowledge of the dirty data.

Sometimes the dirty read matters, and sometimes it doesn't. Other times it matters little enough that it makes sense to
risk an occasional dirty read and thus avoid:

1. The time-consuming work by the DBMS that is needed to prevent dirty reads, and
2. The loss of parallelism that results from waiting until there is no possibility of a dirty read.