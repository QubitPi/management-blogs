---
layout: post
title: HK2 - Dependency Injection Kernel
tags: [Jersey, Dependency Injection, HK2]
color: rgb(8, 86, 112)
feature-img: "assets/img/post-cover/29-cover.png"
thumbnail: "assets/img/post-cover/29-cover.png"
authors: [QubitPi]
excerpt_separator: <!--more-->
---

HK2 is an implementation of JSR-330 in a JavaSE environment. JSR-330 defines services and injection points that can be 
dynamically discovered at runtime and which allow for Inversion of Control (IoC) and dependency injection (DI).

<!--more-->

* TOC
{:toc}

[HK2](https://javaee.github.io/hk2/) provides an API for control over its operation and has the ability to automatically 
load services into the container. It is the foundation for the GlassFish V3 and V4 application servers as well as other 
products.

HK2 also has powerful features that can be used to perform tasks such as looking up services or customizing you injections,
as well as several extensibility features allowing the users to connect with other container technologies

The following list gives an overview of some of the things that can be customized or extended with HK2:

* Custom lifecycles and scopes
* Events
* AOP and other proxies
* Custom injection resolution
* Assisted injection
* Just In Time injection resolution
* Custom validation and security
* Run Level Services

Introduction to HK2
-------------------

HK2 2.0 API, which is based on [JSR-330](https://qubitpi.github.io/jersey-guide/finalized/2022/06/27/jsr-330.html) 
standard annotations, is a declarative framework for services using annotations like Contract and Service. 

### Getting Started

In order to mark a concrete implementation class as one that should be available as a service you annotate your class
with [**`@Service`**](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Service.html).

```java
@Service
public class Foo {

    ...
}
```

By default `Foo` will be advertised as itself and by any interfaces that are marked with
[**`@Contract`**](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Contract.html). Lets make `Foo` an 
interface that is a Contract and create an implementation of `Foo`:

```java
@Contract
public interface Foo {
    
    ...
}
```

```java
@Service
public class FooImpl implements Foo {
    
    ...
}
```

The `FooImpl` class will be placed into the registry advertised under both `FooImpl` and `Foo`.

### Named Services

In order to differentiate different implementations of the same interface you can name your services. Here is an example
of a class that implements a contract and has two implementations, both named differently:

```java
@Contract
public interface Book {
    
    ...
}
```

```java
@Named
@Service
public class MobyDick implements Book {
    
    ...
}
```

```java
@Named
@Service
public class ParadiseLost implements Book {
    
    ...
}
```

The two classes, MobyDick and ParadiseLost, will be added to the service registry with the names "MobyDick" and 
"ParadiseLost". If you use the [Named qualifier](https://qubitpi.github.io/jersey-guide/finalized/2022/06/27/jsr-330.html#named) 
without specifying a name then the name you get is the class name without the package.

### Qualified Services

Services can also be qualified with annotations called qualifiers. Qualifiers are annotations that are themselves 
annotated with [`@Qualifier`](https://qubitpi.github.io/jersey-guide/finalized/2022/06/27/jsr-330.html#qualifier). Here is an
example contract with three implementations:

```java
@Contract
public interface Color {
    
    ...
}
```

```java
@Blue
@Service
public class BlueColor implements Color {
    
    ..
}
```

```java
@Red
@Service
public class RedColor implements Color {
    
    ...
}
```

```java
@Yellow
@Service
public class YellowColor implements Color {
    
    ...
}
```

The Blue annotation, for example, is defined like this:

```java
@Qualifier
@Retention(RUNTIME)
@Target({ TYPE, METHOD, FIELD, PARAMETER })
public @interface Blue { }
```

The `@Red` and `@Yellow` annotations are defined similarly.

### Basic Injection

Lets make our example a little more interesting by injecting a book into Foo. This is done using the JSR-330 standard 
[Inject](https://qubitpi.github.io/jersey-guide/finalized/2022/06/27/jsr-330.html#inject) annotation:

```java
@Service
public class FooImpl implements Foo {
    
    @Inject 
    private Book book;
    
    ...
}
```

Upon construction the book field will be filled in by HK2. You can also inject into the constructor of FooImpl, or use
an initializer method. In both of those cases the constructor or method must be annotated with
[`@Inject`](https://qubitpi.github.io/jersey-guide/finalized/2022/06/27/jsr-330.html#inject) in order to tell HK2 which is the proper constructor or method to call.

Here is `FooImpl` implemented with constructor injection:

```java
@Service
public class FooImpl implements Foo {

    private final Book book;

    @Inject
    public FooImpl(Book book) {
        // constructor injected!
        this.book = book;
    }
}
```

Here is FooImpl implemented with initializer method injection:

```java
@Service
public class FooImpl implements Foo {
    
    private Book book;

    @Inject
    public void setBook(Book book) {
        // initializer method injected!
        this.book = book;
    }
}
```

In all three of the above cases (field injected, constructor injected or initializer method injected) the injection will 
occur prior to the `postConstruct` method of `FooImpl`. In this example we use the injected book in the postConstruct 
method:

```java
@Service
public class FooImpl implements Foo {

    @Inject
    private Book book;

    @PostConstruct
    private void postConstruct() {
        book.doSomething();
    }
}
```

### Injection by Name

The astute observer of our example will have noticed that when injecting a `Book` into `FooImpl` that we never selected 
which book we wanted. That can be fixed by using the
[Named](https://qubitpi.github.io/jersey-guide/finalized/2022/06/27/jsr-330.html#named) qualifier at the point of injection. Lets 
fix the example by injecting both of the Books we defined earlier:

```java
@Service
public class FooImpl implements Foo {

    @Inject @Named("MobyDick")
    private Book mobyDick;

    @Inject @Named("ParadiseLost")
    private Book paradiseLost;
}
```

The implementation of Book given the name "MobyDick" will be injected into the mobyDick field, and the implementation of 
Book given the name "ParadiseLost" will be injected into the paradiseLost field.

### Injection by Qualifier

Injections can also be more specifically chosen by using qualifiers. In the previous example we created three
implementations of Color, each of which was qualified with a qualifier. Here we create a class called ColorMixer which 
injects the colors in an initializer method, which also demonstrates that an initializer method (or constructor) can
take more than one parameter:

```java
@Service
public class ColorMixer {

    private Color red;
    private Color blue;
    private Color yellow;

    @Inject
    private void addPrimaries(@Red Color red, @Blue Color blue, @Yellow Color yellow) {
        this.red = red;
        this.blue = blue;
        this.yellow = yellow;
    }
}
```

Note that the qualifiers can go on the parameters of the initializer method addPrimaries. In the above example the 
`RedColor`, `BlueColor`, and `YellowColor` services will be injected into the proper fields of the initializer.

### Provider Injection

There are times when your code would like **finer control over when a instance of a service is created**. Anywhere that 
you can inject a service, you can also inject a [Provider][Provider]. When you inject a Provider for a service rather 
than the service itself the system will potentially delay the creation of the service until the `get` method of the 
Provider has been called.

Lets go back to our ColorMixer example, and inject providers (into fields this time) for our primaries.

```java
@Service
public class ColorMixer {

    @Inject @Red
    private Provider<Color> redProvider;

    @Inject @Blue
    private Provider<Color> blueProvider;

    @Inject @Yellow
    private Provider<Color> yellowProvider;
}
```

This service can then get the color implementations later. In this method of ColorMixer we create purple by getting the 
red and blue colors:

```java
@Service
public class ColorMixer {
    
    ...

    public Color makePurple() {
        return mix(redProvider.get(), blueProvider.get());
    }
}
```

Note that if no-one ever makes a color that involves using yellow, that the `YellowColor` implementation class will
never be created, since no-one ever called the `get` method of the `yellowProvider` field.

The value passed into any [Provider][Provider] injection point will be an instance of
[`IterableProvider`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/IterableProvider.html).

### IterableProvider Injection

It is often the case that a single contract has more than one implementation. Sometimes it is useful to get access to
all of the implementations of the contract. This can be done by using an
[`IterableProvider`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/IterableProvider.html).
`IterableProvider` extends `Provider` and also implements `Iterable`. Anywhere a service can be injected an 
`IterableProvider` for that service can be injected.

In this example we create a Library service that wants to be able to list all of the books it carries:

```java
@Service
public class Library {

    @Inject
    private IterableProvider<Book> allBooks;

    public LinkedList<Book> getAllBooks() {
        LinkedList<Book> retVal = new LinkedList<Book>();

        for (Book book : allBooks) {
            retVal.add(book);
        }

        return retVal;
    }
}
```

Since `IterableProvider` implements `Iterable` it can be used in Java for/while loops, as demonstrated in the example
above.

Another feature of the `IterableProvider` is that it can be used to further narrow down the selection criteria at run 
time. In our above example we can programmatically choose the book we are interested in based on a name passed into a 
method. Here is how it would look:

```java
@Service
public class Library {

    @Inject
    private IterableProvider<Book> allBooks;

    public Book findBook(String name) {
        return allBooks.named(name).get();
    }
}
```

In the above example we call the
[`named`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/IterableProvider.html#named-java.lang.String-)
method in `IterableProvider` in order to select the book with the given name. The call to get then just returns the book 
with the given name.

### Iterable injection

[`Iterable`](http://docs.oracle.com/javase/6/docs/api/java/lang/Iterable.html) can be used as an injection point rather 
than [IterableProvider](#iterable-injection). The following code will work as expected:

```java
@Service
public class Library {

    @Inject
    private Iterable<Book> allBooks;

    public LinkedList<Book> getAllBooks() {
        LinkedList<Book> retVal = new LinkedList<Book>();

        for (Book book : allBooks) {
            retVal.add(book);
        }

        return retVal;
    }
}
```

The value passed into any `Iterable` injection point will be an instance of `IterableProvider`.

Getting Started
---------------

### Maven Build

The best way to use HK2 in your builds is to add the following dependency in your maven build:

```xml
<project>
    ...
    
    <dependencies>
        <dependency>
            <groupId>org.glassfish.hk2</groupId>
            <artifactId>hk2</artifactId>
            <version>2.5.0-b36</version>
        </dependency>
    </dependencies>
</project>
```

The org.glassfish.hk2:hk2 dependency has a dependency on all of the HK2 jars. However, this may be more than you want, 
since it includes configuration, run-level services and some osgi support that your application may not need. If instead 
you wanted the absolute minimum working profile for hk2 you would instead have your project look like this:

```xml
<project>
    ...

    <dependencies>
        <dependency>
            <groupId>org.glassfish.hk2</groupId>
            <artifactId>hk2-locator</artifactId>
            <version>2.5.0-b36</version>
        </dependency>
    </dependencies>
</project>
```

The hk2-locator project contains the implementation of the hk2 API, with no other bells and whistles. In particular, the 
ability to automatically detect services is not available, and so all HK2 objects must be added programmatically and 
gotten with the HK2 API. However, the above is perfect for small projects that want to play with the HK2 API to see how
it works.

### Automatic Service Population

In order for HK2 to automatically find services at runtime it can read files called **inhabitant files**. These are 
usually placed in your JAR file at location META-INF/hk2-locator. Normally the file is named "default". (You can however 
use a different file name or location(s) by using more specific API). HK2 has a tool for automatically creating these 
files based on class files annotated with
[`@Service`](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Service.html). There is also a simple API
for creating and populating a
[`ServiceLocator`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/ServiceLocator.html) with services found
in these files.

In order to have your Maven build generate the META-INF files that hk2 reads in order to populate a
[`ServiceLocator`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/ServiceLocator.html) use the 
[hk2-inhabitant-generator](#inhabitant-generators). This tool can be used from the command line, or it can be put
into your maven or ant builds.

In order to have your program automatically load the files generated with the hk2-inhabitant-generator you can use the 
[createAndPopulateServiceLocator](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/utilities/ServiceLocatorUtilities.html#createAndPopulateServiceLocator())
method near the start of your main method, like this:

```java
public static void main(String argv[]) {

        ServiceLocator locator = ServiceLocatorUtilities.createAndPopulateServiceLocator();

        MyService myService = locator.getService(MyService.class);

        ...
}
```

#### Inhabitant Generators

There are two ways to generate hk2 metadata (called inhabitant files) that can be used by the runtime system to find hk2 
services without having to classload those services. The first is the **HK2 Metadata Generator**, which works with the 
javac build tool, and the second is the **HK2 Inhabitant Generator** which can be used at build time with any build
system or even post build time with JARs or can be embedded in other tools.

The HK2 Metadata Generator is easy to use, as all it requires is to be on the javac classpath. The HK2 Inhabitant 
Generator is also easy to use but requires the user to specify lines in the build system files (besides just
dependencies). Users can choose whichever tool works for them in their build environment.

##### HK2 Metadata Generator

The HK2 Metadata Generator will generate hk2 inhabitant files during the compilation of your java files. It is a JSR-269 
annotation processor that handles the
[`@Service`](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Service.html) annotation. The only
requirement for using it is to put the javax.inject, hk2-utils, hk2-api and hk2-metadata-generator libraries in the 
classpath of the javac process.

In this example we use the HK2 Metadata Generator in a Maven based build system:

```xml
<dependency>
    <groupId>org.glassfish.hk2</groupId>
    <artifactId>hk2-metadata-generator</artifactId>
</dependency>
```

Since Maven uses transitive dependencies this is all you need to add as a dependency during build.

###### HK2 Metadata Generator Options

By default the HK2 Metadata Generator places the output file in "META-INF/hk2-locator/default". This behavior, however,
can be modified by setting the option `org.glassfish.hk2.metadata.location` to the desired location. This is done with
the javac compiler using the `-A` option. 

##### HK2 Inhabitant Generator

The HK2 Inhabitant Generator is a utility that will generate inhabitants file during the build of your JAR file. It
works by analyzing the classes that have been built by javac and then creating the file "META-INF/hk2-locator/default"
(by default) in your JAR file that has information in it about all of the classes that you have marked with
[`@Service`](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Service.html) or
[`@Contract`](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Contract.html).

The HK2 Inhabitatants Generator can be used as a standalone command-line tool, or it can be embedded in any Java
program. It can also be used in a Maven build. An Eclipse build and an ant task are also planned. Here are the ways that 
the HK2 Inhabitants Generator can be used:

###### Command Line Tool

The HK2 Inhabitants Genertor can be run from the command line like this:

    java org.jvnet.hk2.generator.HabitatGenerator

By default the [`HabibatGenerator`](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/generator/HabitatGenerator.html) 
will attempt to analyze the first element of the classpath and replace that element (if it is a JAR) with a new JAR that 
has an inhabitants file in it describing all of the classes marked with
[`@Service`](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/annotations/Service.html). If the first element of the 
classpath is a directory it will attempt to create a new inhabitants file in that directory describing all of the classes marked with `@Service`.

You can modify this behavior by using command line options. Here is the usage statement for `HabibatGenerator`:

```
java org.jvnet.hk2.generator.HabitatGenerator
  [--file jarFileOrDirectory]
  [--outjar jarFile]
  [--locator locatorName]
  [--verbose]
```

* The `-file` option allows the user to pick a directory or JAR file to analyze for classes marked with `@Service`.
* The `-outjar` option allows the user to pick the output JAR file that the generator should create with the inhabitants file in it.
* The `-locator` option allows the user to name the locator that these services should go into. This value is "default"
  by default.
* The `-verbose` option make the generator print extra information as it does its work.

This command line utility will call `System.exit` when it is done with a 0 code if it was able to work properly and a 
non-zero value if it failed in some way.

###### Embedded Usage

The class
[`org.jvnet.hk2.generator.HabitatGenerator`](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/generator/HabitatGenerator.html) has a static method on called **`embeddedMain`**. The 
`embeddedMain` takes the typical `argv[]` array of parameters and so has the same behavior as the
[command line usage](#command-line-tool). The biggest difference is that this method returns an `int` as the return
code, either 0 for success or non-zero for failure and does not call `System.exit()`. See the its
[javadoc](https://javaee.github.io/hk2/apidocs/org/jvnet/hk2/generator/HabitatGenerator.html) for more information.

Using `embeddedMain` is useful if you want to build your own build tools that generate inhabitants files for your own
IDE or other build environment.

###### Using Maven

The `HabitatGenerator` is also available as a Maven plugin. It has a single goal, called **generateInhabitants** that
is run in the process-classes phase by default. Using this plugin in your build will cause inhabitants files to be 
generated in your output directory.

The following example plugin snippet from a `pom.xml` will run the `InhabitantsGenerator` in both the main tree and in
the test tree, in case you would like your test sources to also be analyzed for classes marked with `@Service`.

```xml
    <plugin>
        <groupId>org.glassfish.hk2</groupId>
        <artifactId>hk2-inhabitant-generator</artifactId>
        <version>2.5.0-b36</version>
        <executions>
            <execution>
                <goals>
                    <goal>generate-inhabitants</goal>
                </goals>
            </execution>
        </executions>
    </plugin>
```

The plugin has the following configuration options:

* `test` Set to `true` if this execution should be for the tests rather than main
* `outputDirectory` (the place the output file will go, defaults to `${project.build.outputDirectory}`)
* `testOutputDirectory` (the place the output will go if test is `true`, defaults to `${project.build.testOutputDirectory}`)
* `verbose` (`true` or `false`)
* locator (The name of the locator file which is "default" by default)
* noswap (`true` or `false`) if set to `true` the generator will overwrite files in place which is riskier but faster

###### Ant Task

The inhabitant generator can also be used as an ant task. The ant task is
`org.jvnet.hk2.generator.maven.ant.HK2InhabitantGeneratorTask`. Below find an example ant file that uses the task:

```xml
<project name="HK2 Ant Build File" default="build" basedir=".">
    <!-- set global properties for this build -->
    <property name="src" location="src"/>
    <property name="build" location="target/classes"/>
  
    <taskdef name="hk2-inhabitant-generator" classname="org.jvnet.hk2.generator.ant.HK2InhabitantGeneratorTask"/>
  
    <target name="compile" >
        <!-- Compile the java code from ${src} into ${build} -->
        <javac srcdir="${src}" destdir="${build}"/>
        <hk2-inhabitant-generator targetDirectory="${build}"/>
    </target>
</project>
```

> 📋 In the example above, the hk2-inhabitant-generator must run after the classes are built, as the
> hk2-inhabitant-generator inspects the class files.

The ant plugin has the following options:

* `targetDirectory` (the directory to find the classes, defaults to target/classes)
* `outputDirectory` (the place the output file will go, defaults to target/classes)
* `verbose` (`true` or `false`)
* locator (The name of the locator file which is "default" by default)
* noswap (`true` or `false`) if set to `true` the generator will overwrite files in place which is riskier but faster

##### Stub Generation

The HK2 metadata generator can also generate implementation classes based on abstract classes. This is useful when 
testing, as it is often the case in tests that the user would like to replace some service with one that does nothing or 
does only a few special things during the test. This is done by putting the Stub annotation on an abstract class. Any 
abstract methods NOT implemented by the class will have dummy implementations generated in a java file that also has an 
Service annotation. This will then become an service in the Singleton scope, which should show up when using most hk2 
initialization methodologies. The benefits of using the Stub annotation include:

* The service need not be completely implemented. Only those methods that need to return specific data needed by the
  test need to be implemented
* The [Rank](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/Rank.html) annotation will work when placed on
  the abstract class, so the stub can be given higher priority than the replacement class
* Using Stub means that this abstract class may not need to be updated if the underlying interface or class has an added 
* method
* It makes it very easy to write very simple test replacement classes

In this simple example there is an interface with a large number of methods:

```java
@Contract
public interface ManyMethodsService { 
    
    void methodA();
    void methodB();
    int methodFoo();
    String methodBar(String input);
}
```

Somewhere in your build there is an implementation of `ManyMethodsService`. It may or may not look like this:

```java
@Service
public class ManyMethodsServiceImpl implements ManyMethodsService {
    
    // Here we really implement the interface, possibly doing JDBC or other possibly heavy operations
}
```

However, in the test environment there is only one or two methods that the test touches. In this case we can very easily 
use the Stub annotation to tell the hk2-metadata-generator to generate an implementation that fills in the missing 
methods. This test version of the service might be implemented like this:

```java
@Stub
@Rank(1)
public abstract class TestManyMethodsService implements ManyMethodsService {

    // Only implement the methods that the test actually touches, and return
    // hard-coded data
    public int methodFoo() {
      return 13;
    }

    public String methodBar(String input) {
      return input;
    }

    // Do not implement the other methods in the interface
}
```

If the hk2-metadata-generator is in the classpath of the test build then it will see the Stub annotation and will
generate a java file with the unimplemented methods implemented, returning either `null` or 0 or "a" along with an added 
Service annotation. Since the Rank annotation is set to 1 in the abstract class (`TestManyMethodsService`) it will be
used in favor of the true implementation (`ManyMethodsServiceImpl`).

If there is a `@Named` qualifier on the class annotated with Stub that qualifier will also be copied to the resulting 
implementation class. If `@Named` has no value associated with it the value used will be the value of the class with
Stub on it. For example this class:

```java
@Stub
@Named
public abstract class AliceService implements SomeInterface {
    
    ...
}
```

will end up having the name "AliceService", while this class:

```java
@Stub
@Named("Bob")
public abstract class AliceService implements SomeInterface {
    
    ...
}
```

will end up having the name "Bob". Only the `@Named` qualifier is treated specially in this way.

The Stub annotation can also generate implementations where rather than returning `null` or zero values it throws 
`UnsupportedOperationException` (with the name of the method called in the message). This can be done by setting the
value field of the Stub to `EXCEPTIONS`, like this:

```java
@Stub(Stub.Type.EXCEPTIONS)
public abstract class AliceService implements SomeInterface {
    
    // All generated methods will throw UnsupportedOperationException
}
```

This can be useful when writing tests to ensure that the code does not inadvertently use one of the methods of the
stub's implementation.

HK2 API
-------

### ServiceLocator

The most fundamental service in HK2 is the
[**`ServiceLocator`**](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/ServiceLocator.html). The
`ServiceLocator` represents the registry where services are looked up and where information about services (known as 
**`Descriptors`**) are bound into the registry. The `ServiceLocator` itself is represented as a service in its own 
registry; it is always the first service bound into its own registry.

`ServiceLocators` are named uniquely in a JVM and each has a unique locator ID. It is possible to create or find 
ServiceLocators using a
[**`ServiceLocatorFactory`**](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/ServiceLocatorFactory.html).
The `ServiceLocatorFactory` will normally use a default implementation of
[**`ServiceLocatorGenerator`**](https://javaee.github.io/hk2/apidocs/org/glassfish/extension/api/ServiceLocatorGenerator.html)
specified in `META-INF/services`. The default implementation can be changed by having a different `META-INF/services` 
specification of the implementation of `ServiceLocatorGenerator` earlier in the classpath than the provided
implementation. An implementation of `ServiceLocatorGenerator` can also be given directly to the `ServiceLocatorFactory` 
create method.

Once you have created a `ServiceLocator` with the `ServiceLocatorFactory` it will contain at least three services:

* Itself (see `ServiceLocator`)
* The default JSR-330 resolver (see [`InjectionResolver`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/InjectionResolver.html))
* A service for configuring further services (see [**`DynamicConfigurationService`**](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/DynamicConfigurationService.html))

### Adding in Your own Services

While the three services in your `ServiceLocator` are nice, they hardly constitute a useful system. What is needed is all 
of your services, in order to make it useful. Also please note that this section assumes that you are not using the upper 
level system that automatically reads in the descriptions of your services and populate `ServiceLocators` for you. For information on how that system works see [here](#getting-started).

**You add your own service by using the
[`DynamicConfigurationService`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/DynamicConfigurationService.html)**. `DynamicConfigurationService` is one of the set of services automatically added to every ServiceLocator. You 
can get that service by simply looking it up:

```java
public void initialize() {
    ServiceLocatorFactory factory = ServiceLocatorFactory.getInstance();
    ServiceLocator locator = factory.create("HelloWorld");
    DynamicConfigurationService dcs = locator.getService(DynamicConfigurationService.class);
    
    ...
}
```

**You use the `DynamicConfigurationService` to create `DynamicConfiguration` instances**. The `DynamicConfiguration` 
interface has a few methods for binding in descriptions of your services.

In order to bind in services you need to first create a description of your service. A description of your service gives 
information about the service, such as the name of the implementation class, and the name of the classes or interfaces 
which the service should be available to be looked up as, and other information. In general, any implementation of 
[Descriptor](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/Descriptor.html) can be used, but we have
provided at least two mechanisms for creating Descriptors that you might want to use. We will go through those
mechanisms in the next two sections, and then come back to adding in your own descriptor to your newly created 
ServiceLocator.

#### BuilderHelper Binding EDSL

An EDSL is an Embedded Domain Specific Language that allows you to build up objects specific to your particular domain.
In this case we provide an EDSL for building Descriptors.

Lets take an example. Suppose I wanted to tell the system about a service of mine that has implementation class
`com.acme.internal.WidgetImpl` which implements the `com.acme.Widget` contract (interface) and which is in the PerLookup 
scope (which means a new instance of WidgetImpl will be provided for every injection point). Here is how a descriptor
that contains all of that information can be built up using our EDSL:

```java
public Descriptor createWidgetDescriptor() {
    return BuilderHelper
        .link("com.acme.internal.WidgetImpl")
        .to("com.acme.Widget")
        .in("org.glassfish.api.PerLookup")
        .build();
}
```

The [`BuilderHelper`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/utilities/BuilderHelper.html) link method 
creates a
[`DescriptorBuilder`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/utilities/DescriptorBuilder.html), which
then creates more and more specific versions of itself as you fill in the data with calls to `to` or `in` or
`qualifiedBy`.

Finally, when you are finished filling in all the details of your service, you call `build()` in order to produce a 
`Descriptor` that can be used in a bind call of
[`DynamicConfiguration`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/DynamicConfiguration.html).

It is interesting to note that the build call of DescriptorBuilder produces a
[`DescriptorImpl`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/utilities/DescriptorImpl.html). A
`DescriptorImpl` is nothing more than a convenience implementation of `Descriptor` that has settable fields. Hence, if 
your code wanted to use the EDSL to produce a basic `Descriptor` and then further customize it with the added methods of 
`DescriptorImpl` it could do so.

#### DescriptorImpl

Rather than create your own implementation of `Descriptor` we have provided an implementation of `Descriptor` called 
`DescriptorImpl`. This implementation has convenient methods for setting all of the fields of Descriptor. It should be 
noted that the bind API of `DynamicConfiguration` will make a deep copy of whatever `Descriptor` is passed to it, and
that the underlying implementation of the HK2 API never uses the `DescriptorImpl` class directly. It is purely there as
a convenience class for those who wish to provide their own `Descriptors`.

Here is an example that achieves the same `Descriptor` as the example in the previous section but uses the 
`DescriptorImpl` to do it:

```java
    public Descriptor createWidgetDescriptor() {
        DescriptorImpl retVal = new DescriptorImpl();
        
        retVal.setImplementation("com.acme.internal.WidgetImpl");
        retVal.addAdvertisedContract("com.acme.internal.WidgetImpl");
        retVal.addAdvertisedContract("com.acme.Widget");
        retVal.setScope("org.glassfish.api.PerLookup");
        
        return retVal;
    }
```

> 📋 One interesting thing to notice in the code above is that we added the implementation class as an 
> `advertisedContract`. This was done automatically for us in the `BuilderHelper` case, but needed to be explicitly done 
> in this case.

#### Binding a Descriptor into a ServiceLocator

Now that we have seen two simple ways to create a Descriptor lets take a look at how we bind that descriptor into our 
`ServiceLocator`. Here is an example:

```java
public void initialize() {
    ServiceLocatorFactory factory = ServiceLocatorFactory.getInstance();
    
    ServiceLocator locator = factory.create("HelloWorld");
        
    DynamicConfigurationService dcs = locator.getService(DynamicConfigurationService.class);
        
    DynamicConfiguration config = dcs.createDynamicConfiguration();
        
    config.bind(createWidgetDescriptor());
        
    config.commit();
}
```

The method `createWidgetDescriptor` is from the preceding examples. Here we call the `createDynamicConfiguration` method 
of `DynamicConfigurationService`. This creates an instance of DynamicConfiguration. To use a `DynamicConfiguration` you 
call the bind or unbind methods until you are happy with the change and then you call commit to make the changes occur
for real in the system. If you do not call commit none of the changes you added to the `DynamicConfiguration` instance 
will be made to the system.

That is all there is to it! The services you add in this manner can now be looked up or injected into other services or 
generally manipulated through all of the other methods in `ServiceLocator`.

#### Convenience Methods for Adding Services

There are several convenience methods that we have added to simplify the task of adding descriptors to a service
locator. These are encapsulated in the
[`ServiceLocatorUtilities`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/utilities/ServiceLocatorUtilities.html)
class.

If you already have a service class and you would like for hk2 to automatically analyze the class and add it to a
locator then you can use the
[`addClasses`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/utilities/ServiceLocatorUtilities.html#addClasses%28org.glassfish.hk2.api.ServiceLocator,java.lang.Class...%29)
method.

If you already have an instance of a service and you would like hk2 to automatically analyze the class of the service
and add it to a locator then you can use the
[`addOneConstant`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/utilities/ServiceLocatorUtilities.html#addOneConstant%28org.glassfish.hk2.api.ServiceLocator,java.lang.Object%29)
method

If you already have a descriptor for a service and you would like hk2 to add it to a locator then you can use the 
[`addOneDescriptor`](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/utilities/ServiceLocatorUtilities.html#addOneDescriptor%28org.glassfish.hk2.api.ServiceLocator,org.glassfish.hk2.api.Descriptor%29) method

#### Looking Up Services

There are several mechanisms for looking up services in HK2. The simplest is to just call getService method of 
`ServiceLocator` with the class of the service you are interested in:

```java
Widget widget = locator.getService(Widget.class);
```

The type passed in can be any implementation class or interface with which the service was bound with as an advertisable 
contract. If there is no `Widget` that can be found in the system then the getService method will return `null`. If
there are more than one `Widget` (e.g. `Widget` is an interface that can have many implementations) then the best
`Widget` will be returned from the `getService` method.

Services are sorted by (in order) the service ranking, the largest locator id (so that services in children are picked 
before services in parents) and smallest service id (so that older services are picked prior to newer services).
Therefore the best instance of a service is a service with the highest ranking or largest service locator id or the
lowest service id. The ranking of a service is found in its `Descriptor` and can be changed at any time at run time. The 
locator id of a service is a system assigned value for the `Descriptor` when it is bound into the `ServiceLocator` and
is the id of that `ServiceLocator`. The service id of a service is a system assigned value for the `Descriptor` when it
is bound into the `ServiceLocator`. The system assigned value is a monotonically increasing value. Thus if two services have the same ranking the best service will be associated with the oldest `Descriptor` bound into the system.

#### Looking Up Services by Name

Services can be qualified in many ways, but the most common is to have a name associated with the service. Hence, in our **Widget** example if there are several **Widgets** in the system but each has a different name we can find our 
particular **Widget** like this:

```java
public Widget getNamedWidget(String name) {
    return locator.getService(Widget.class, name);
}
```

The given name is used to further qualify the specific **Widget** that was bound into the system.

#### Looking Up Services with Qualifiers

If your services have qualifiers you can look them up via the qualifiers. In order to do this you can use the 
[**`AnnotationLiteral`**](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/AnnotationLiteral.html) in order to 
create concrete implementations of your annotations. Let's see how this would be done. Suppose you have a qualifier
called **Blue**, defined like this:

```java
@Qualifier
@Retention(RUNTIME)
@Target( { TYPE, METHOD, FIELD, PARAMETER })
public @interface Blue { }
```

Normally you wouldn't implement **Blue**, but in this case you do need an implementation in order to be able to look it 
up. You do that by providing an implement of **Blue** that extends **AnnotationLiteral**:

```java
public class BlueImpl extends AnnotationLiteral<Blue> implements Blue { }
```

You can now use this `BlueImpl` to look up your qualified `Widget` in a `ServiceLocator` like this:

```java
Widget widget = locator.getService(Widget.class, new BlueImpl());
```

This will get the Widget that has been qualified with `@Blue`.

#### Getting All Services

You may also want to get all of the services that have advertised a certain contract. You can do this like this:

```java
List<Widget> widgetList = locator.getAllServices(Widget.class);
```

The list returned will have as many `Widgets` that could be found in the system. It is important to note in this case
that all of the `Widgets` will have been **classloaded** when you use this call, so if classloading performance is 
important to you be careful of using the `getAllServices` method. Instead, consider using the `getAllServiceHandles` or 
`getDescriptors` method.

#### Getting Service Descriptors

If you want to look up service descriptors rather than the services themselves you can use the `getDescriptor` or 
`getBestDescriptor` methods on `ServiceLocator`. The `getDescriptor` and `getBestDescriptor` methods will never cause 
classloading to occur, so it is safe to use in environments where classloading can be an issue.

The `getDescriptor` methods on `ServiceLocator` use a `Fitler` to determine which Descriptors to return. You can
implement your own `Filter` or you can use one of the `Filter` implementations provided by `BuilderHelper`. The most 
common case is to use an `IndexedFilter` provided by `BuildHelper`, like this:

```java
IndexedFilter widgetFilter = BuilderHelper.createContractFilter(Widget.class.getName());
List<ActiveDescriptor<?>> widgetDescriptors = locator.getDescriptors(widgetFilter);
```

Using an
[**`IndexedFilter`**](https://javaee.github.io/hk2/api-overview.html#builderhelper-binding-edsl:~:text=Using%20an%20IndexedFilter%20can%20greatly%20improve%20the%20search%20time%20for%20your%20Descriptors.) can greatly improve the search time for your Descriptors.

#### Unmanaged Creation, Injection and Lifecycle

There are times when you would like to have an object created, injected or have its lifecycle methods called by HK2, but 
not have that Object be explicitly managed by HK2. The `ServiceLocator` has methods that suit this case. These methods 
will inspect the class or object given and will attempt to perform the requested operations, without keeping track or 
managing those objects in any way.

The first method is the `create` method, which will attempt to create an instance of the given class using the
dependency injection rules of HK2:

```java
Widget widget = locator.create(WidgetImpl.class);
```

It is important to note that the only references to other beans that will have been initialized when this returns are 
those necessary to perform constructor injection. Hence any `@Inject` fields or `@Inject` initializer methods will NOT 
have been initialized when this method returns.

If you already have an object, and would like for its `@Inject` fields and `@Inject` initializer methods to get filled 
in, you can use the `inject` method:

```java
locator.inject(widget);
```

The object given will be analyzed and all of the fields and methods will be injected upon return. However, any 
`postConstruct` method on the object will not have been called yet. That can be done with the `postConstruct` method:

```java
locator.postConstruct(widget);
```

This method call will find the `postConstruct` method on `widget` and call it. Once the user is finished with the
object, they can force the `preDestroy` to be called on it by using the `preDestroy` method:

```java
locator.preDestroy(widget);
```

This sequence can be very useful when there is some special processing that needs to happen and the user does not want
to have HK2 manage the objects themselves.

Extensibility
-------------

### Events

The HK2 event service provides a pluggable mechanism that allows for delivery of messages from service to service. Those 
services sending events are called **publishers** and those receiving events are called **subscribers**. A **message**
can be any java object.

#### Topics

A [**`Topic`**](https://javaee.github.io/hk2/apidocs/org/glassfish/hk2/api/messaging/Topic.html) is a special HK2
service that can be injected into a service or can be looked up from a `ServiceLocator`. It normally is injected as a 
parameterized type, where the generic type is the class of the event that will be published. So if there is an event 
class called `ImportantEvent` that is to be distributed to subscribers, the injection point for the `Topic` might look
like this:

```java
@Inject
Topic<ImportantEvent> importantEventTopic;
```

[Provider]: https://qubitpi.github.io/jersey-guide/finalized/2022/06/27/jsr-330.html#provider